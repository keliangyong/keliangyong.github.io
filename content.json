[{"title":"模块化：require.js及r.js基础","slug":null,"date":"2016-05-22T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/22/模块化：require-js及r-js基础/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"require js的基本配置文件格式如下：requirejs.config({ baseUrl: &quot;src/js&quot;, paths: { &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos; } }); baseUrl作用：给后续所引用的模块自动添加一个前缀，也就是说后续所引用的模块的地址是在此url基础上加引用时的小部分路径构成的。baseUrl的基准：以引用config的那个html文件的所在目录为基准。paths的作用：为一些跨baseUrl目录或在当前目录下路径较长的模块做路径设置，在引用有设置paths的模块时，会用baseUrl+paths作为路径去获取模块。paths的用法：例如，大部分模块在module中，而我的jquery因为分类是库，所以放在lib下了，此时baseUrl兼顾大众需求设为&#39;js/module&#39;，而对于jquery因为不在module下所以我在paths中单独给它设路径为&#39;../lib/jquery&#39;。 requirejs.config({ baseUrl:&apos;js/module&apos;, paths:{ jquery:&apos;../lib/jquery&apos; } }); r.js 的打包配置文件格式如下：({ baseUrl: &quot;./src/js&quot;, paths: { &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos; }, name: &quot;main&quot;, out: &quot;dist/js/merge.js&quot; }) baseUrl：这个baseUrl是基础路径，它的任务是搭配paths或下方name、out的路径来找到对应的模块、解析起始点（即name）、输出位置（即out），它是以自身所在目录为基准的。name：是解析入口，搭配上面的baseUrl拼接出路径，拼接出的路径要指向require.js的配置文件；图中的解析入口就是&quot;./src/js/main.js&quot;，从main.js开始解析打包。","raw":null,"content":null,"categories":null,"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"}]},{"title":"模块化：常见规范","slug":null,"date":"2016-05-21T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/21/模块化：常见规范/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"什么是模块化？为什么要模块化？命名冲突：为了方便也避免重复造轮子，我们习惯于把一些通用的、底层的工具抽离出来，例如写成一个函数放在另一个文件中，我们需要的时候再去引用就可以；但是在工具中被定义的变量我不能在当前文件使用，因为会产生冲突导致工具无法正常使用。所以我们希望这个工具能是一个独立的空间，不要影响到当前页面的开发。文件依赖：当我们在写一个新工具的时候，有可能会需要调用其它功能更小的工具；那么在执行时因为js的同步特性，要使用这个新工具就必须要先加载小工具，也就是说小工具要先于新工具去引入；当引入文件较多或者顺序乱了之后维护起来非常困难。原因：使用模块化主要是为了解决两个问题：命名冲突和文件依赖。模块化x命名冲突：用面向对象的方式将方法、工具绑在对象上；约定用关键字exports暴露接口返回对象。模块化x文件依赖：约定关键字require来获取对象将文件依赖内置，不需要外部引入。 CMD、AMD、CommonJS 规范分别指什么？Common JS：它是一个规范，它通过定义丰富的能解决一些通常的应用开发需求的API来补足了js官方关于标准库的不足。建立它的意图是希望开发者可以运用这些API去开发应用，而且所开发的应用能够在不同的js环境中运行而不仅仅是浏览器。服务器端的javascript应用node.js就是运用Common JS的一个例子，服务器端的程序比浏览器端要更复杂，也需要与操作系统和其他程序互动，因此服务器端必须要模块块以便应对上述问题。node.js参照Common JS 规范创建了模块系统，模块系统通过exports暴露接口返回对象，通过require获取接口返回的对象。例如 // math.js文件 的内容： exports.method=function(){ var obj=xxx; // doing something return obj; }; // main.js文件 的内容： var newObj= require(&apos;math&apos;).method; // 当然 main.js可以继续exports接口 以供其他文件调用 AMD：&quot;Asynchronous Module Definition&quot;即异步模块定义，实现AMD的库有RequireJS 、curl 、Dojo 等。在服务器端采用的Common JS规范到浏览器端因为同步执行加载的问题会导致浏览器在加载获取时处于假死状态什么都不能做只能等引用加载完，AMD在这种环境下诞生了；AMD采用异步加载的方式去获取引用的js，待加载完成后采取执行对应程序，从而避免了等待和浏览器假死的状况。它的语法和应用如下： // 语法 define(id?,dependencies?,factory); // id 即对这个模块命名 // dependencies 这个模块所依赖的其他模块 多个时用数组传递 // factory 加载完成后执行的回调函数 // math.js文件 定义模块 define(function(){ var obj=xxx; // doing somethig return obj }) // main.js文件 加载模块 define(method,[&apos;math&apos;],function(math){ //把加载的模块传递进来 doing something }) CMD：CMD（Common Module Definition）是Sea JS推广过程中产生的。在 CMD 规范中，一个模块就是一个文件。其语法与comment js类似，不过多了一个外包装；且相对与AMD的提前设置依赖，CMD的区别就是它将依赖内置了，需要时就使用require去获取，从表面上看实现了comment js的浏览器端化，但实质是通过设置外包装 define(function(require, exports, module){}来包裹代码，提前去加载引用的模块，等加载完成后再同步执行。 // 语法 一个模块就是一个文件 define(factory); //math.js 定义 define(function(require, exports, module){ exports.obj=xxx; }) // main.js 加载引用 define(function(require, exports, module){ var method=require(&apos;math&apos;).obj; //doing something }) // 当然这个模块也可以继续exports接口 让其他模块调用","raw":null,"content":null,"categories":null,"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"}]},{"title":"javascript的继承特性","slug":null,"date":"2016-05-19T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/19/Javascript的继承特性/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"继承有什么作用? 创造新对象的时候无需重复写一些共有的属性，new的时候会继承给新对象。 继承后，共有的属性和方法是共用的，避免浪费大量的资源。 也方便对一些具有相同特性的对象进行统一修改。 常见的创建对象的方式主要有以下几种12345678910111213141516171819202122// 方法1 用直接定义object的方法var obj1=&#123; name:&apos;keliangyong&apos;, age:25&#125;;// 方法2 用函数创造的方法 参数传递进去 把obj return出来function creatObj(name,age)&#123; var obj=&#123; name:name, age:age &#125;; return obj;&#125;var obj2=creatObj(&apos;keliangyong&apos;,25);// 方法3 用构造函数的方法new一个对象function CreatObj(name,age)&#123; this.name=name; this.age=age;&#125;var obj3 = new CreatObj(&apos;keliangyong&apos;,25); Object.create 在继承中的使用Obj.create(复制目标[,额外属性/值])，创建一个拥有指定原型和若干指定属性的对象。当我有一个构造函数Person，现在想在Person的基础上做一个新的构造函数Student，Person有的我想让Student也有，同时我自己再去给Student加新的属性。123456789101112131415161718// 初始定义function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName=function()&#123; console.log(this.name);&#125;function Student(name, sex, grade)&#123; Person.call(this, name, sex); this.grade=grade;&#125;// 方法一 new创建法Student.prototype = new Person; //这样Student的原型中就有Person的所有东西了 但是有很多奇怪的东子也放进去了；比如多了name：undefind，sex：undefined 强迫症表示很难受 想要个干干净净的原型var s1 = new Student(&apos;小柯&apos;, &apos;男&apos;, &apos;大四&apos;);// 方法二 Object.creat创建法Student.prototype = Object.create(Person.prototype); // OK 完成 完美 var s1 = new Student(&apos;小柯&apos;, &apos;男&apos;, &apos;大四&apos;); hasOwnProperty简介hasOwnProperty可以用来判断一个属性是不是这个对象自身所有的，格式obj.hasOwnProperty(prop),如果是自身所有就会返回true，若不是自身所有而是继承来的话就会返回false. Object.create的 polyfill的实现// 以下是参考了MDN中关于Onject.create的Polyfill写法 Object.copy=function(proto){ if(typeof proto !== &apos;object&apos;){ throw TypeError(&apos;Object prototype may only be an Object or null&apos;); } function Example(){}; // 新建一个空构造函数 Example.prototype=proto; // 考虑到作为原型，所以肯定都是引用类型 直接赋值指向 var obj = new Example(); // 因为最终返回的是原型对象 Example.prototype=null; if(arguments.length&gt;1){ // 如果参数大于1 说明有附加属性需加入 for(var prop in arguments[1]){ if(proto.hasOwnProperty(prop)){ // Object.create要求此处仅自身拥有的可枚举属性才有效 obj[prop]=arguments[1][prop]; // 所以就用hasOwnProperty来判断。 } } } return obj; } 通过call去实现已有构造函数特性的复制function Person(name, sex){ this.name = name; this.sex = sex; } function Male(name, sex, age){ Person.call(this, name, sex); //把当前环境作为Person函数的this去执行 在new Male时新对象就成了Person中的this指向 this.age = age; } 已有一个构造函数，用继承特性在此基础上创造一个新的构造函数//补全代码，实现继承 （难度:****） function Person(name, sex){ this.name=name; this.sex=sex; } Person.prototype.getName = function(){ return this.name; }; function Male(name, sex, age){ Person.call(this,name,age); this.age=age; } Male.prototype=Object.create(Person.prototype); Male.prototype.printName = function(){ console.log(this.getName()); }; Male.prototype.getAge = function(){ return this.age; }; var ruoyu = new Male(&apos;若愚&apos;, &apos;男&apos;, 27); ruoyu.printName();","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"对象、原型","slug":null,"date":"2016-05-18T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/18/对象、原型/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"OOP 及其特性OOP：全称 Object Oriented Programming，面向对象程序设计。传统的计算机程序是由一系列的指令和函数组成，而面向对象编程的程序是由一个个独立的代码块也就是对象组成的，一个个对象分工合作完成任务。特性： 继承性：由构造函数所创建的对象会继承其创造者的一部分公共属性。 多态性：由继承而产生相关的不同实例会有不同的具体功能。 封装性：在一个对象的内部，某些代码是私有的不能被外界访问到的。 如何通过构造函数的方式创建一个拥有属性和方法的对象先定义一个函数，里面用this.xx等设置相关值和函数，就是属性和方法啦，然后用new关键字创建一个对象就可以了；例如： function People(name,age){ this.name=name; this.age=age; this.introduce=function(){ console.log(&apos;Hello , My name is &apos;+this.name+&apos; I am &apos;+age+&apos; years old&apos;); } } var jon = new People(&apos;jon&apos;,20); prototype 及其特性prototype：是原型的意思，在javascript中每个对象都有原型也就是prototype属性。这个属性存的是一个地址，指向一个原型对象。可以用这个属性来给对象添加固有属性。特征：在原型中所拥有的特性，继承的对象都会有，因为继承的对象都会有一个proto属性指向原型。 画出如下代码的原型图function People (name){ this.name = name; this.sayName = function(){ console.log(&apos;my name is:&apos; + this.name); } } People.prototype.walk = function(){ console.log(this.name + &apos; is walking&apos;); } var p1 = new People(&apos;饥人谷&apos;); var p2 = new People(&apos;前端&apos;); 变量namefunction People (){ var name = &quot;饥人谷&quot; // 这个name 是函数内的 局部变量 this.name = &quot;我&quot;; // 这个name 根据this指向不同而不同 正常运行时是window全局变量；new一个新对象时又是指代新对象的name属性 } People.name = &quot;jscode&quot;; // 这个name 是People这个函数的一个属性 函数也是对象 People.prototype.name = &quot;学前端&quot;; // 这个name是People的原型的一个属性 这样做以后 用People构造的对象就都会继承name这个属性了，但是如果复写的话就会被覆盖。 小练习1.创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatusfunction Car(name,color,status){ this.name=name; this.color=color; this.status=status; this.run=function(){ this.status=&apos;run&apos;; } this.stop=function(){ this.status=&apos;stop&apos;; } this.getStatus=function(){ return this.status; } } var car = new Car(&apos;byd&apos;,&apos;white&apos;,&apos;stop&apos;); 2.创建一个 GoTop 对象，当 new 一个 GotTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部；拥有以下属性和方法 ct属性，GoTop 对应的 DOM 元素的容器 target属性， GoTop 对应的 DOM 元素 bindEvent 方法， 用于绑定事件 createNode 方法， 用于在容器内创建节点 &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function GoTop($ct){ this.ct=$ct; this.target=$(&apos;&lt;button&gt;点我回到顶部&lt;/button&gt;&apos;); this.creatNode=function(){ this.ct.append(this.target); } this.bindEvent=function(){ this.target.on(&apos;click&apos;,function(){ $(window).scrollTop(0); }) } this.creatNode(); this.bindEvent(); } var goTop = new GoTop($(&apos;body&apos;)); &lt;/script&gt;","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Http","slug":null,"date":"2016-05-16T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/16/Http/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"OSI 七层模型OSI：Open System Interconnection Refer Model 开放式系统互联通信参考模型，是由国际标准化组织提出的一种概念模型，是一个试图让各种计算机在全世界范围内连成网络的标准框架；它将网络通信分成七个层面。从距离用户最近至最底层简述如下： 应用层 Application：用户交互的对象，用户通过这一层进行信息交互。通俗点例如chrome浏览器、或者发邮件的outlook就是这一层。 表示层 Presentation：这一层是操作系统所在的层，处理数据，转化加密等确保另一个系统能识别你的数据。 会话层 Session：负责你的电脑与服务器的通信连接与维护，创建连接→请求→响应。 传输层 Transport：把传输表头加至数据以形成数据包，控制调节数据的传输，决定类似一次发送多少数据的问题。 网络层 Network：路由的工作层，它决定路径的选择和转寄。 数据链路层 Data Link：交换机的工作层，负责网络寻址、错误侦测和改错。 物理层 Physical：最底层的物理联网介质和数据传输实现，网线、连接器及比特流的传输等。 HTTP 的工作原理HTTP 全称 Hyper Text Transfer Protocol 即超文本传输协议；它是一个客户端终端和服务器端请求和应答的标准。它的请求和响应步骤如下： 建立连接：客户端与服务器端建立一个TCP连接。 发起请求：客户端向服务器端发起Http请求，会发送请求报文，由请求行、消息报头和请求正文组成。 返回响应：服务器端接收到请求并进行解析，定位请求资源，给客户端发送响应报文，由状态行、消息报头和响应正文组成。 释放TCP连接：服务器关闭TCP连接。（如果连接模式是keepalive的话会保持一段时间可继续接受请求） URI 的格式及常见的协议URI 全称Uniform Resource Identifier 统一资源标志符，是一个用于标识一个互联网资源名称的字符串。由两个子集构成，通过描述资源位置确定资源的URL，以及通过名字来识别确定资源的URN。它的格式如下： &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;hash&gt;http:// user:pass@www.example.com :80 /dir/index ?uid=1&amp;nam=2 #ch1 &lt;scheme&gt; 协议方案名 常见的有http、https等。 &lt;user&gt;:&lt;password&gt; 用户的登录信息 现在一般不会把登录信息放在url中。 &lt;host&gt; 服务器地址 用户一般使用域名方便记忆，浏览器经DNS解析去访问对应IP地址。 &lt;port&gt; 端口号 服务器的进程接口，80是http协议默认的端口号，ftp协议默认21端口，https默认443端口。 &lt;port&gt; 路径 找到服务器后再去对应的路径下寻找资源。 &lt;params&gt; 在一些协议中需要参数来访问资源，参数用名值对用；隔开。 &lt;query&gt; 查询字符串，常见的是get请求中data以此形式传给服务器。 &lt;hash&gt; 片段标识符-哈希，之前作为页面锚点的时候见过。 常见的协议有 Http、Https、FTP、SSH等。 HTTP 协议几种和服务器交互的方法 GET：得到，最常用的方法，向服务器发送请求要求获取某个资源。 HEAD：头，亦即不需要数据主体只想得到描述资源信息的头部，一般用于查看资源信息、查看状态码看下资源是否存在、查看首部看下资源有没有被修改。 POST：投递，好理解，就是向服务器发数据，一般是在html表单中用于向服务器提交表单信息的。 PUT：放，就是向服务器写入资源，修改某个内容。 TRACE：跟踪，这个方法会在最后发往服务器时，返回一个TRACE响应给客户端，告诉客户端最终服务器收到的请求报文是什么样的。 DELETE：删除，要求服务器删掉给定url下的资源，服务器可能不会支持。 OPTIONS：其他，用来查询服务器支持哪些功能。 状态码200，301， 304，403 , 404 , 500，503分别代表什么意思 200 OK 请求已成功 根据请求方式的不同会有不同的反馈内容 301 Moved Permanently 所请求的资源被永久性地移动到另一个地方 响应会返回新的url 下次客户端会按照新的url去访问 304 Not Modified 客户端有缓存的文档 当再一次发起请求时 服务器经比对后发现文档内容并没有变化时就会返回此状态码 让客户端使用本地缓存 403 Forbidden 服务器已经理解请求 但拒绝执行 一般是因为没有对应的权限 404 Not Found 请求失败 在服务器上找不到你所请求的资源 500 Internal Server Error服务器出错了 无法完成客户端的请求 503 Service Unavailable服务器过载了 目前无法处理客户端的请求 报文由哪几部分组成http报文有请求报文和响应报文，是一个简单的格式化数据块，它由以下3个部分组成： start line：起始行 对报文进行简单描述 header：包含一些属性的首部块 body：数据的主题部分，有些请求不需要返回这部分 请求头的格式和作用作用：为请求添加额外的信息，来告诉服务器客户端的信息和能力，服务器可以据此为客户端提供更好的响应。格式：是名/值的形式；名字后面跟着冒号，加上可选的空格，再加上字段值，最后回车或换行。范例： GET/HTTP/1.1 请求方法、协议、版本号 ←这是请求报文起始行 Host：服务器地址 Connection：连接方式 一般请求后就断开 图中是keep-alive，可以继续接收请求。 Accept：说明我这个客户端可以接受哪些类型的资源。 Upgrade-Insecure-Requests：自动升级请求，在https承载的页面上不允许出现http请求，出现就会报警，这个属性会自动替换https请求。 User-RefererAgent：用户代理也就是浏览器客户端自身的信息。 Referer：客户端是从哪里跳转过来的。例如我们从百度跳到饥人谷官网，这里就会是百度的网址。 Access-Encoding：客户端可以接受的编码类型。 Accept-Language：客户端可以解析接受的语言。 Cookie：服务器端为了辨识用户身份而留在客户端的数据，发送请求时客户端会把cookie一起发送给服务器。 首部的格式和作用作用：HTTP的首部向请求或响应报文添加了一些附加信息，它是一些名/值对的列表。它分为通用首部、请求首部、响应首部、实体首部和拓展首部。格式：名字后面跟着冒号，加上可选的空格，再加上字段值，最后回车或换行。范例： HTTP/1.1 200 OK 协议/版本 状态码 释义 ←这是响应报文起始行 不属于首部 Server：属于响应信息性首部，服务器用的是哪一种及版本 图中用的是nginx 版本1.6.2 Data：属于通用信息性首部，提供日期和事件说明报文是什么时候创建的。 Content-Type：属于实体内容首部，告诉客户端主体的数据类型。 Transfer-Encoding：属于通用信息性首部，传输的编码方式，图中chunked是分块传输例如小说分一章一章传输。 Connection：属于通用信息性首部，可以指定请求/响应的连接选项，图中keep-alive在响应后连接依然可以存在一段时间。 X-Powered-By：显示此资源用什么技术开发及对应版本 感觉只有PHP Expires：属于实体缓存首部，提示缓存过期的时间，超过这个时间就需要重新获取资源。 Pragma：属于通用缓存首部，另一种随报文传送的指示，并不专用于缓存。 Cache-Control：属于通用缓存首部，随报文传送缓存指示，图中private是指私人缓存每个人不一样。 Content-Encoding：属于实体内容首部，告诉客户端对主体执行的编码方式。 Vary：属于响应协商首部，是一个首部列表，服务器会根据这些首部的内容挑出最适合的资源版本发给客户端。 主体的作用 实体的主体部分就是HTTP要传输的内容了，一般是图片、视频、HTML文档等。下面饥人谷首页的响应实体，也就是HTML文档了。 浏览器缓存是如何控制 是什么：浏览器缓存是web缓存中的一个类型，与公用缓存不同，浏览器一般都有内建的私有缓存，会缓存已经访问过的页面，也就是把资源复制了一份放在本地，缓存可以减少网络带宽的压力、降低服务器的压力、也能让我们更快地打开页面获得资源。 缓存页面、过期时间：在我们首次请求资源或页面时，原始服务器利用HTTP的cache-control首部或expires首部给文档加上了过期时间，标明了保质期。在保质期内请求已缓存的资源时，浏览器就不会向服务器发送请求而是直接使用本地缓存。 过期后的再验证：当过了保质期以后呢，这个时候浏览器就会向服务器发起请求同时附带过期时间。若文档与缓存的副本不一样服务器就响应新的文档给浏览器，同时浏览器会继续缓存新的文档；若服务器比对后发现文档没有变化，就会发个新的过期时间让浏览器继续使用本地缓存。对缓存再验证最有用的两个首部是If-Modified-Since和If-None-Match。最后引用博客园的一张图面解释，更加清晰。 If-Modified-Since：当资源过期时，再请求时若发现资源带有Last-Modified（最后修改日期）声明时，会带上If-Modified-Since：Last-Modified Data发给服务器，收到后服务器就会比对最后修改时间，若没被修改就返回304 Not Modified响应报文并且附带新的过期事件；若被修改了就返回新的文档和过期时间。 If-None-Match：如果在资源过期后再请求时发现资源带有Etage声明（资源在服务器的唯一标识，生成规则服务器自定），会带上If-None-Match：Etage值发给服务器，收到后服务器就会进行比对校验来决定返回200还是304，响应与If-Modified-Since相同。 下图各个参数是什么意思General：概述 Request URL：请求的资源的URL也就是位置 Request Method：客户端向服务端发出请求的方法，图中是用PUT方法 Status Code：状态码，图中是200 表示成功OK Remote Address：资源所在的IP地址 Response Headers 响应头 Connection：连接方式；图中是keep-alive，在请求后的一段时间内还是相连的，可直接继续发送请求。 Content-Length：主体的长度或尺寸 Content-type：主体的类型 Date：报文创建的时间 Server：服务端软件及版本，图中是Nginx/1.6.2 X-Powered-By：开发资源的技术是Express Request Headers 请求头 Accept：我这个客户端可以接受哪些类型的资源 Accept-Encoding：客户端可以接受的编码类型 Accept-Language：客户端可以解析接受的语言 Cookie：服务器端为了辨识用户身份而留在客户端的数据，发送请求时客户端会把cookie一起发送给服务器。 Host：服务器地址 Origin：所请求的资源的源 Referer：客户端是从哪里跳转过来的。例如我们从百度跳到饥人谷官网，这里就会是百度的网址 User-Agent：用户代理也就是浏览器客户端自身的信息 X-Requested-With：请求的方式，这里是AJAX","raw":null,"content":null,"categories":null,"tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"This、闭包","slug":null,"date":"2016-05-14T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/14/this、闭包/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"apply、call 的作用及区别 作用：在指定this值和参数值的前提下去调用函数或方法。 区别：A for array,C for comma ! apply方法接受的是一个包含多个参数的数组，而call方法接受的是一个参数列表。 theFunction.call( this, arg1, arg2, arg3... ) theFunction.apply( this, [arg1,arg2,arg3...] ) 小练习1.以下代码输出什么?var john = { firstName: &quot;John&quot; } function func() { alert(this.firstName + &quot;: hi!&quot;) } john.sayHi = func // 把 func 拷贝了一份，存在对象john的sayHi属性中 john.sayHi() // 输出 &quot;john: hi!&quot; 这个函数的拥有者是john这个对象 this指向john 2.下面代码输出什么，为什么func() // 输出 window对象 这个函数的拥有者是window对象或称全局对象 function func() { alert(this) } 3.下面代码输出什么function fn0(){ function fn(){ console.log(this); } fn(); } fn0(); // 输出window对象 fn0这个函数的拥有者是window对象 其内部的this指向window对象 document.addEventListener(&apos;click&apos;, function(e){ console.log(this); // 点击 输出document对象 实质是拷贝了一份函数给document的click属性 这个函数属于document对象 setTimeout(function(){ console.log(this); // 200毫秒后 输出window对象 setTimeout是运行在全局环境下的 属于window对象 }, 200); }, false); 4.下面代码输出什么，whyvar john = { firstName: &quot;John&quot; } function func() { alert( this.firstName ) } func.call(john) // 输出 &quot;John&quot; call在指定了john作为this的前提下去调用了func 5.代码输出？var john = { firstName: &quot;John&quot;, surname: &quot;Smith&quot; } function func(a, b ) { alert( this[a] + &apos; &apos; + this[b] ) } func.call(john, &apos;firstName&apos;, &apos;surname&apos;) // 输出 &quot;John Smith&quot; call在指定john作为this的前提下调用了func 6.以下代码有什么问题，如何修改var module= { bind: function(){ $btn.on(&apos;click&apos;, function(){ console.log(this) //this指的是btn这个元素 实质拷了一份函数给btn的click属性 函数属于btn this.showMsg(); // 报错 这不是一个函数 }) }, showMsg: function(){ console.log(&apos;饥人谷&apos;); } } var module= { bind: function(){ var self=this; $btn.on(&apos;click&apos;, function(){ console.log(this) self.showMsg(); // 本来我是直接改成module的 看了老师对育薇同学的点评 发现以后改名的话会出问题 其他人不容易发现里面这个东西。。维护太艰难 也意识到工程化模块化的重要性了 }) }, showMsg: function(){ console.log(&apos;饥人谷&apos;); } } 7.下面代码输出什么? whyobj = { go: function() { alert(this) } } obj.go(); // 输出 obj对象 这个函数属于obj (obj.go)(); // 输出 obj对象 全局中并没有这个函数 函数还是在obj中是属于obj的 (a = obj.go)(); // 输出 window对象 函数被赋值给了全局变量a再遇到括号执行了 这个函数属于window对象 (0 || obj.go)(); // 输出 obj对象 看了同学们的解释才知道 多了一个传递的过程 以一个全局变量做中转来存储结果 所以与上一例相同","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"同源策略、跨域","slug":null,"date":"2016-05-12T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/12/同源策略、跨域/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"什么是同源策略 协议名+域名+端口就是源，三者都相同视为同源。 不同源的客户端脚本在没有明确授权下，不能读写对方的资源（可引用js、css、png）。例：a.com域名下的js无法操作b.com域名下的对象。 什么是跨域？跨域的几种实现形式 同源策略在保证web安全的同时，也降低了网站交互的灵活性；有些大网站因为文件多数据大所以文件可能放在不同的服务器上，那么就有了突破同源策略的限制，以达到交互数据的目的。跨域就是指当域名不同时，我能够突破同源策略的限制去交互数据。（协议和端口不同的话在前台是无法实现的）。 跨域有以下几种实现形式： 降域：对于有相同的后缀（就是域名开头不一样但后面是一样的）的两个源，可以使用document.domain=&quot;域名后缀&quot;来改变自己的域名，这样就同源了！(两个源都要设置domain才可)一个域名可以往下降（降为后缀）但不能往上升，但降域后可以回复到原来的域名，测试图如下： jsonp：上一题提到不同源虽然不能读写，但可以引用js，关键点在这；我们可以让引用的js附带数据来调用我们预先定义的函数，而数据当作参数传入。例如：a和b两个网站约定好了一个函数名，当a用src引用b的js时，b中的这段js包含这个函数名并且在后面加个括号中间放入数据，从b的角度来看这段js只是数据名（{json数据}），但是在a看来，你的那个数据名在我这是个函数啊，你还有括号和形参，然后在a中这个函数就被调用执行了，而b中的数据就被当作参数传入这个函数。 CORS：跨域资源共享这是一个W3C标准，顾名思义它允许浏览器向跨源服务器发起XMLHttpRequest请求，和ajax同源的使用方法一致（区别在于对于跨域请求浏览器的请求会有附加的相关设置，用户看不到），分简单请求和非简单请求。目前所有浏览器都支持（IE需要10及以上才完全支持）CORS，但是需要服务器端有CORS接口，且要有服务器许可的源才可实现跨域资源共享。 [HTML5]postMessage：在HTML5中，window增加了一个新方法postMessage用于给目标源发送信息，格式如下：windowobj.postMessage(message,targetOrigin)，而目标源会有一个叫message的事件用来监听postMessage，判断是允许的源所发来的数据后，就可以接收做处理。 hash方法：url→（协议+域名+端口+路径+查询字符串+片段标识符），其中片段标识符就是hash以#开头；因为同源策略不允许读写但可以引用，那么我在a中引入一个iframe（内联框架-另一个页面）且src指向b.html，此时的src是a页面输入的；然后我在b页面中用location.hash去修改自身hash也就是数据赋给hash，此时我再去a页面读取iframe的属性src，这个src就会被更新带有hash,处理后我就得到了b中的数据了。（此方法要注意a读取src的时机，要不停地去检测是否变化）→→（上面叙述有误，不能直接修改location.hash，被同源禁止，而是要在b中再新建一个指向a.com并且带有b中数据做hash的代理iframe，利用这个代理iframe与a.com同源的特性，再修改父父页面也就是a.com的hash，这样a读取hash就得到了数据，可参考最后一题实践截图，但基本原理是对的，就不改了） window.name方法：与hash方法类似，这个方法的核心是利用window.name不随域名改变而变化，只随tab页面的开启关闭而改变的特性。据此特性，我在a页面添加一个iframe，这个iframe指向代理1页面；代理1页面干两件事，把要传给b的数据命名为自己的windowname，修改自身location.href跳转到b；b读取windowname知道了a想要什么，就去数据库查，找到后把数据赋值给windowname，location.href跳转到代理2页面；代理2页面干两件事，读取windowname，用window.parent.函数名调用父window(即a页面)的函数；此时a页面提前定好的函数就doing啦，a啥也不干，就空想数据到来后怎么处理，然后插个iframe告诉代理1自己想要什么就可以坐等数据来了，人生赢家！ jsonp 的原理 jsonp的原理：先串通好，你先把数据用括号包起来再加个名字，对就是json格式的数据带名字滴，像data({xxx:&#39;xxx&#39;,xxx:&#39;xxx&#39;})这样，记得文件类型改成js；我利用可跨域引用的特点来引用你的js，定个函数起名就和那个数据名字一样，你那边的带名字的数据的js到了我这，咦你数据名和我函数名一样呢，很明显呐就变成一个赤裸裸的带参数的函数，不好意思我看到函数就执行啦，数据就被当成函数参数啦，一切都是套路。（正经的可以参考上一题的jsonp，因为有点重复就用更加通俗的语言来写一写，印象更深刻） CORS Cross Origin Resource sharing 跨域资源共享，为了满足日益增长的跨域交互需求（折腾）W3C推荐了这种机制，它与我们用的ajax同源请求有什么区别么？有，多了一些组件、请求头等相关设置，但基本还是原来的配方，还是XMLHttpRequest这个对象，正常向有许可的网站发起ajax请求即可！现在它合法了只要对方允许你读取就可以。其实当你读取另一个站的资源时，浏览器就已经发起跨站请求了（现在基本新版浏览器都支持CORS，IE就不说了），只不过因为你没得到对方网站的允许（对方页面未声明你可以访问它），所以浏览器拦截了返回结果并只是告诉你，你不能跨域什么的，以上，可参考上一题。 小练习本地搭建服务器，演示同源策略 修改了本地host 让多个网址映射到本地服务器 我在a.11.com下用ajax向11.com发起请求 浏览器报错：提示XMLHttpRequest加载失败，请求我帮你发出去了，服务器也给我结果了，但是我在服务器的返回结果的头部没有发现‘请求控制允许源’这么一个东西（Tips：如果有那就是CORS啦），所以a.11.com你的访问是不被允许的。那么这就是同源策略，没有对方允许不能读写对方资源！ 至少使用一种方式解决跨域问题 降域：我在a.11.com和11.com中都赋值domain=&quot;11.com;注意要两个页面都给domain赋值！！用iframe的方法。 jsonp：把数据用json格式弄好包成js文件放在b.22.com，我在a中引用b中的js，并定义一个同名函数来打印数据。 CORS：这个简单，我在b.com加个声明，允许a.com来访问我，然后用ajax请求就OK！ [html5]postMessage：我在a.com中用iframe.contentWindow.postMessage(&#39;message&#39;,targetOrigin )给b.com发送消息，在b.com中给window绑定监听事件，如果message触发我先判断是不是a发来的，是我就打印，搞定！ hash方法：hash方法的原理是a内嵌iframe指向b，b找到数据并新建一个和a.com同源的iframe而且把数据放在路径hash中，利用新建的iframe与a同源的特性修改父父页面也就是a页面的hash（把自己的hash赋给父父hash），a再去读取自身hash即可。a.com下的a.11.htm和代理proxy.htmll如下： &lt;p&gt;我是a.11.com&lt;/p&gt; &lt;iframe src=&quot;//b.22.com/test/b.22.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var data =location.hash.substring(1); console.log(data); &lt;/script&gt; &lt;p&gt;我是a.com下的 proxy.html&lt;/p&gt; &lt;p&gt; 作用是代理&lt;/p&gt; &lt;script&gt; parent.parent.location.hash=self.location.hash.substring(1); &lt;/script&gt; window.name方法：tab页面不随域名跳转改变而改变，我先建一个内联iframe修改window.name跳转去b，b读取就知道我想要什么，然后b去找数据，找到后b把数据赋给window.name，再跳转回来，我读取winwod.name就得到数据。 &lt;p&gt;我是a.11.com&lt;/p&gt; &lt;iframe src=&quot;//b.22.com/test/b.22.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function print(data){ console.log(data); } &lt;/script&gt; &lt;!-- //以下是 b.22.com 下的 b.22.html &lt;p&gt;我是b.22.com&lt;/p&gt; &lt;script&gt; window.name=&apos;这是来自b.com的数据&apos;; location.href=&apos;//a.11.com/test/a.proxy.html&apos;; &lt;/script&gt; --&gt; &lt;!-- //以下是 a.11.com 下的 a.proxy.html &lt;p&gt;我是a.com下的 proxy.html&lt;/p&gt; &lt;p&gt; 作用是代理&lt;/p&gt; &lt;script&gt; window.parent.print(window.name); &lt;/script&gt; --&gt;","raw":null,"content":null,"categories":null,"tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Jquery 常用方法","slug":null,"date":"2016-05-10T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/10/Jquery常用方法/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Jquery 中， $(document).ready()和window.onload 的区别 $(document).ready()是指当DOM加载完成可以被javascript去操作时就会执行ready括号中的函数。 和window.onload 的区别如下： 1.$(document).ready()是jquery中的方法，等DOM树就绪后就会执行；window.onload是原生js中的一个对象，不仅要等DOM树就绪还要图像、内部框架等，页面整个加载完呈现出来才会执行。 2.$(document).ready()像事件绑定的原理，可以设置多次，DOM加载完就执行所有预先设置的函数；window.onload因为是类似给window对象的onload属性赋值所以只能执行一个，后设置的将覆盖前面的。 3.$(document).ready()可以简写成$(func)；window.onload没有简写。 其他写法：$(document).ready()可以简写成$(func)；替代方法的话没有，但是需要注意jquery中的另外一个$(window).load( )它会等图像、内部框架等，页面整个加载呈现完才执行而不仅仅是DOM。 $node.html() 和 $node.text() 的区别 和原生Js类似；$node.html()是获取或设置node节点的html内容，输出时包含标签代码写入时标签代码也会正常生效； $node.text()是获取或设置node节点的文本内容，输出时是把内部所有文本做一个拼接后输出，输入时把节点内部整个清空放入输入值（注意标签代码会被转义为文本）。 $.extend 的作用和用法 $.extend的作用是将多个对象的值（与目标对象比较，把目标对象所没有的值添加到目标对象中）合并到目标对象中。 用法：$.extend(true,target,obj1[,objn])，若不需要深拷贝请将第一个参数true去掉（注意不支持false！）。注意数组或对象浅拷贝时target的值可能会被覆盖而不是添加，此时最好用深拷贝！目标对象可以是一个空对象（例如想合并两个对象，把其中一个作为目标对象的话会被修改，我既想得到合并后的对象，也想保留这两个对象，这时可以用一个空对象去做target） JQuery 的链式调用 链式调用：在jquery中，它的很多方法调用后的返回值依然是jequery对象，那么对于像对DOM进行操作的任务中我们就无需先取得元素赋值给新建变量，再针对这个新建变量进行操作；例如$(&#39;#head&#39;)它是一个表达式，和被选中的id为head的这个元素是等价的，$(&#39;#head&#39;).find(&#39;.box&#39;)就表示先选中id为head的元素再在head元素下寻找class为box的元素，当然后面还可以接着给它绑定事件。 链式调用非常方便，真的是write less do more！，而且思路也很清晰，让代码看起来更简洁易懂。 JQuery ajax 中缓存怎样控制 一般来说浏览器会将每次请求的内容缓存起来，这样的话下次是同样的请求就直接在本地调用无需再发请求，但有时候如果是版本更新或者不想让浏览器使用缓存时怎么办呢？ 在jquery.ajax(opts)中有一个参数是cache，我们把它设为false即可让浏览器不读取本地缓存，其原理是类似在请求中加时间戳，这样浏览器以为两次请求是不同的而不会去调用缓存，但时间戳并不影响数据的获取，我们得到的依然是我们想要的。 jquery 中 data 函数的作用 在jquery中data函数允许我们把一些数据绑定到DOM元素上，避免循环引用的内存泄露风险；例如$(&#39;#head&#39;).data(name:&#39;hello&#39;)是在id为head的这个元素上绑定了一个数据，其名为name，值为’hello’，下次这样引用$(&#39;#head&#39;).data(name)。 小练习写出以下功能对应的 Jq 方法：1.给元素 $node 添加 class active，给元素 $noed 删除 class active $node.addClass(&apos;active&apos;); $noed.removeClass(&apos;active&apos;); 2.展示元素$node, 隐藏元素$node $node.show(); //展示 $node.hide()；//隐藏 3.获取元素$node 的 属性: id、src、title， 修改以上属性 $node.attr(&apos;id&apos;); $node.attr(&apos;src&apos;); $node.attr(&apos;title&apos;); $node.attr({ id:&apos; &apos;， src:&apos; &apos;， title:&apos; &apos;， }); 4.给$node 添加自定义属性data-src $node.attr(&apos;data-src&apos;:&apos; &apos;); 5.在$ct 内部最开头添加元素$node $ct.prepend($node); 6.在$ct 内部最末尾添加元素$node $ct.append($node); 7.删除$node $node.remove(); 8.把$ct里内容清空 $ct.text(&apos;&apos;); $ct.empty(); 9.在$ct 里设置 html $ct.html(&apos;&lt;div class=&quot;btn&quot;&gt;&lt;/div&gt;&apos;); 10.获取、设置$node 的宽度、高度(分别不包括内边距、包括内边距、包括边框、包括外边距) $node.width(); //获得宽度 不包括内边距 仅内容大小 $node.width(30); //设置宽度 $node.height(); //获得高度 $node.height(30); //设置高度 $node.innerWidth(); //包含内边距用inner $node.outerWidth(); //包含边框用outer $node.outerWidth(true); //包含外边距用outer+true 11.获取窗口滚动条垂直滚动距离 $(document).scrollTop(); 12.获取$node 到根节点水平、垂直偏移距离 $node.offset(); 13.修改$node 的样式，字体颜色设置红色，字体大小设置14px $node.css({ &apos;color&apos;: &apos;red&apos;, &apos;font-size&apos;: &apos;14px&apos; }); 14.遍历节点，把每个节点里面的文本内容重复一遍 .each(function(index,element){ $(this).text($(this).text()+$(this).text()); }); 15.从$ct 里查找 class 为 .item的子元素 $ct.find(&apos;.item&apos;); 16.获取$ct 里面的所有孩子 $ct.children(); 17.对于$node，向上找到 class 为’.ct’的父亲，在从该父亲找到’.panel’的孩子 $node.parents(&apos;.ct&apos;).find(&apos;.panel&apos;) 18.获取选择元素的数量 .length; 19.获取当前元素在兄弟中的排行 .index()；","raw":null,"content":null,"categories":null,"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://yoursite.com/tags/Jquery/"}]},{"title":"Jquery Dom、事件","slug":null,"date":"2016-05-09T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/09/Jquery-DOM&事件/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"库和框架的区别 看到的经典回答： 框架帮你挖好坑，你来填！库是给你一把铲子你自己挖！ You call library ,Framework calls you. 库是一些方法的集合；例如你想修改DOM元素时需要选中、修改、放回去步骤繁琐，这时我们可以自己写个函数来专门实现这种功能，你只需要放参数进来它就返回结果给你，不用重复写；这个函数就是库里面的方法，库里面放了很多方法。 框架是设计好的结构，是个可拓展的半成品；例如有一群人都想建房子，那么框架会帮你打好地基、搭好承重梁，等于这个房子的主体搞定了，然后不同人按自己的需要去添砖加瓦去构建自己想要的房子； 从本质上来看，库和框架都是为了减少我们的工作量而服务的。库是着眼于小方面帮你做好工具让你不用每次干活都先造工具，但你去干什么活它不管；而框架呢是着眼于大方面，把一些通用的、基础的（比如不管是谁每次建房子前都要先打地基）给打包在一起，要建房就把那一堆放上去，然后在此基础上再自己去做，但你要用对，建房地基包不能拿去做桥梁的！ jquery jquery是一个又小又快功能丰富的javascript库，它可以让你对DOM元素的遍历和操作、事件、ajax和动画等变得更简单，不需要像原生js那么繁琐，它帮你封装好了，提供了很多API你只要去调用它就能返回结果给你，而且它的方法还兼容各个版本的浏览器。 jquery 对象和 DOM 原生对象的区别及互相转化 jauery对象的外层都是一个中括号包裹的，通过使用$( )得到的，类似[&lt;p&gt;我是段落&lt;/p&gt;]，只有jauery对象才能使用jquery的方法。因为是类数组对象，所以我们可以加个中括号包裹的数字即可得到原生DOM对象，[&lt;p&gt;我是段落&lt;/p&gt;][0]；另外jquery还提供了一个get方法来实现，如[&lt;p&gt;我是段落&lt;/p&gt;].get(0)。 DOM原生对象就是我们通过geElementBy xx得到的节点，例如&lt;p&gt;我是段落&lt;/p&gt;；可以使用$( )来包裹DOM原生对象从而得到jquery对象，$(DOM原生对象)。 jquery中事件绑定 jquery中使用on来绑定事件，对象.on(&#39;事件名称&#39;，&#39;处理函数&#39;)。 bind、unbind、delegate、live、on、off的作用； bind在jquery1.7之前的版本中用于直接给一个元素绑定事件，所以在绑定前元素必须是已存在的。 unbind可以移除元素上用bind绑定的事件，如果没有参数就移除元素上的所有事件。 delegate在jquery1.7之前的版本中使用，一般用于给父元素绑定一个或多个事件，只要匹配的子元素发生事件就会触发。 live在jquery1.7版本被废弃了，给匹配的所有元素绑定一个事件。 on给匹配的元素绑定事件处理函数，可以有多个事件。 off移除用on绑定的事件，如果没有参数则移除所有事件。 推荐使用on来绑定事件，因为它更灵活，而且旧版本中其他绑定方法它都能实现达成了统一。 使用on绑定事件使用事件代理的写法 使用on绑定事件代理写法如下：为ul绑定事件，当li元素发生事件时，触发处理函数。 $(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos;, function(){ }); jquery 中如何展示/隐藏元素？ $().hide()来隐藏元素，可以设置参数来控制执行的时间、方式、回调参数等。 $().show()来隐藏元素，可以设置参数来控制执行的时间、方式、回调参数等。 jquery 动画的使用 使用.animate( )来使用动画，元素.annimate（css属性：值，opts），opt里可以设置较多东西，时间、方式、速度、回调函数等，可以按需要去jquery官网查阅，对于css属性部分要注意必须是值可数字化的css属性，例如宽高可以而背景色就不行。 元素内部 HTML 内容设置和获取、元素内部文本的设置和获取？** HTML内容使用jquery的.html( )，括号内不带内容表示获取所选对象的html内容，带内容的话则将用括号内的内容覆盖其内部html内容。原生js中用.innerHTML获取，用赋值来设置内容。 文本内容使用jquery的.text( )，括号中不带内容表示获取所选对象的文本内容(注意同样是忽略html标签进行文本拼接)，带内容的话则将用括号内的内容覆盖其内部html内容。原生js中用.innerText获取，用赋值来设置内容。 表单用户输入或者选择的内容设置和获取、元素属性的设置和获取 和原生JS中input对象.value类似，jquery中可以使用$( ).val( )来获取表单输入的内容。 元素属性的获取在原生JS中是使用元素.getAttribute，使用元素.settAttribute来设置；而在jquery中获取和设置两种操作是同一个方法，$( ).attr(&#39;属性名&#39;)来获取属性值，$( ).attr(&#39;属性名&#39;，&#39;值&#39;)来对属性值进行设置。","raw":null,"content":null,"categories":null,"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://yoursite.com/tags/Jquery/"}]},{"title":"Ajax基础","slug":null,"date":"2016-05-06T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/06/Ajax基础/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"ajax Ajax全称是Asynchronous JavaScript and XML，指的是通过Javascript脚本发起HTTP通信； 它可以使用原生的XMLHttpRequest对象向服务器发出HTTP请求，这个请求可以是同步或异步的（一般是异步），建立连接后可以得到服务器的数据，我们就可以利用得到的数据通过JS来更新部分页面而无需对整个页面进行刷新。 前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？ 前后端联调需要注意：①确定接口信息；有哪些接口，哪些参数，以什么样的请求等，一般要确定详细的接口文档。②确定要填充的数据，哪里填充图片，哪里填充文本信息等。 在后端接口完成前，我们可以根据接口文档，使用假数据来验证我们制作的页面响应和接口是否正常，可以使用Mock.js，它能拦截ajax请求并根据请求中的内容来随机生成符合你要求的假数据，模拟后端环境让你完成对页面和接口的测试。 点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击? 自己的想法：依目前所学，只有js能实现；第一反应是点击后我把事件移除，你随便点，等加载完成后我在处理函数中再给它绑事件；或者我再给按钮绑个事件，点击后把自己的class给改掉让ajax不能正常触发，不过改class可能会有改变样式的风险，写样式时可以预先加个比如interrupt的类。 网上搜索了一下：自己封装加个比对-如果ajax请求一致的话就不进行提交、提交后把button disable掉、如果点完一个又去点了另外一个的话就abort之前的请求、加个setTimeout+clearTimeOut避免恶意快速点击等。 用js封装了一个 ajax 函数function ajax(opts){ var request = new XMLHttpRequest(); var str = &apos;&apos;; for(i in opts.data){ str += i+&apos;=&apos;+opts.data[i]+&apos;&amp;&apos;; } str = str.substr(0, str.length-1); if(opts.type.toLowerCase() === &apos;get&apos;){ request.open(&apos;GET&apos;, opts.url+&apos;?&apos;+str, true); request.send(); } if(opt.type.toLowerCase() === &apos;post&apos;){ resuest.open(&apos;POST&apos;, opt.url, true); ajax.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); request.send(str); } request.onreadystatechange=function(){ if(request.readyState==4 &amp;&amp; request.status==200){ var responsetext=JSON.parse(request.responseText); opts.success(responsetext); } if(request.status!==200){ opts.error(); } } } document.querySelector(&apos;#btn&apos;).addEventListener(&apos;click&apos;, function(){ ajax({ url: &apos;getData.php&apos;, //接口地址 type: &apos;get&apos;, // 类型， post 或者 get, data: { username: &apos;xiaoming&apos;, password: &apos;abcd1234&apos; }, success: function(ret){ console.log(ret); // {status: 0} }, error: function(){ console.log(&apos;出错了&apos;) } }) });","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"web服务器与http请求","slug":null,"date":"2016-05-04T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/04/web服务器与http请求/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"web 服务器、PHP、数据库、浏览器是如何实现动态网站的 发送请求：浏览器根据用户输入的域名，运用DNS缓存或请求本地DNS服务器解析等获得对应IP地址，使用HTTP协议发送请求报文（含请求内容、浏览器信息、本地缓存、cookie等） 返回数据：web服务器接收到请求，会去寻找对应文件，找到后会反馈给浏览器说请求的内容已经找到。 html文件：web服务器在自己目录下寻找，找到后会直接反馈给浏览器； PHP文件：web服务器会现在自己目录下找PHP文件，找到后它会发给PHP服务器帮忙解析，PHP服务器会将PHP文件翻译成html代码返回给web服务器； 数据操作：如果请求中涉及到数据库的操作的话，同样，web服务器将PHP文件发给PHP服务器，PHP服务器对文件中需要数据库信息的部分请求MySQL数据库提供对应数据，之后PHP服务器再将反馈的数据翻译成html代码发送给web服务器。 渲染呈现：浏览器根据web服务器的反馈，下载数据，进行解析渲染，并将最终页面呈现给用户。 常见的 WEB 服务器 Apache服务器：A pache（哈哈 一个补丁 我乍一听还以为是直升机）使用广泛，开放源代码，支持多个平台，相比其他服务器占的内存较大，是重量级产品。 Microsoft IIS 服务器：微软的，包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，要使用它需要购买对应的商业window server操作系统。 Nginx服务器：（发音同engine x）俄罗斯的一个站点开发的，相比于Apache服务器，Nginx占用内存小且较稳定。 Tomcat服务器：（哈哈 汤姆猫服务器）也是开放源代码的，运行servlet和JSP Web应用软件基于Java，比绝大多数的商业用的软件服务器要好。 打开浏览器，在地址栏输入url 到页面展现，整个过程发生了什么？ 用户输入网址：用户输入网址，包含协议和域名 浏览器获得IP地址：浏览器先找自身缓存看是否有记录，没有的话再找操作系统缓存，再没有就请求本地DNS服务器帮忙，本地DNS再找不到再一层层往上；最终，浏览器获得了对应的IP地址。 浏览器发送请求：浏览器根据HTTP协议，给对应IP地址的主机发送请求报文，默认端口为80，报文含请求内容、浏览器信息、本地缓存、cookie等等信息。 web服务器接收请求、寻找文件：Nginx服务器接收到请求，在自己目录下开始寻找对应php文件 PHP服务器翻译php文件：找到后将文件发给PHP服务器，PHP服务器打开php文件进行翻译，如果碰到需要数据库对应数据的部分，PHP服务器就用标准的SQL查询语句来获取数据库中的数据。 MySQL数据库提供数据：接收PHP服务器指令，会反馈对应数据给PHP服务器。 PHP服务器完成翻译发给web服务器：PHP服务器将php文件翻译生成静态html代码，并发送给web服务器。 web服务器接收并通知浏览器：web服务器接收PHP服务器的html代码，并反馈给浏览器让浏览器开始下载。 浏览器下载：浏览器收到web服务器通知，开始下载请求的所有资源。 浏览器解析渲染：浏览器边下载边解析，并开始生成html树和css树，组合二者并开始渲染页面。 浏览器呈现页面：页面渲染完成，浏览器将饥人谷官网绘制出呈现给用户。","raw":null,"content":null,"categories":null,"tags":[{"name":"Web服务器","slug":"Web服务器","permalink":"http://yoursite.com/tags/Web服务器/"}]},{"title":"javascript Dom、事件","slug":null,"date":"2016-05-03T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/03/Dom、事件/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"dom 对象的 innerText 和 innerHTML 的区别 innerText是指内部文本；读取时会将节点内部的所有文本内容做一个拼接后输出；写入时写入的内容覆盖节点内部所有的内容，并且输入内容会强行转义为文本。 interHTML是指内部html构成；读取时会将内部的子节点及其内容等原封不动输出；写入时也是覆盖内部内容，输入内容含标签是会正常起作用。 elem.children 和 elem.childNodes 的区别 elem.children得到的是elem这个节点的子Html节点的集合（放在数组中）不包含空白文本节点； elem.childNodes得到的是elem这个节点的子节点的集合（放在数组中），但是会包括空白文本节点。所以一般使用elem.children比较多。 查询元素有几种常见的方法 getElementById：通过id来选择元素，返回对应id的元素节点包含其内部元素节点，在document对象下使用； getElementsByClassName：通过类名来选择元素，返回一个储存duiy对应类名的类数组对象，要用arr[i]来使用，在document和element下使用； getElementsByTagName：通过标签名来选择元素，返回一个储存duiy对应类名的类数组对象，要用arr[i]来使用，在document和enement下使用； getElementByName：用来选择一些具有name属性的html元素，比如form、img等，返回一个储存对应类名的类数组对象，要用arr[i]来使用，在document下使用；IE浏览器中会返回没有name属性的同名id元素！ querrSelector：类似css选择器语法，会返回匹配的元素节点，如果有多个满足条件的元素节点将只返回第一个。 querySelectorAll：与querrSelector类似，不过它会返回所有满足条件的元素节点。 创建一个元素、给元素设置属性 用var element=document.createElement（元素名）开创建一个元素； 用元素名.setAttribute（&#39;属性名&#39;，&#39;值&#39;）来给元素设置属性。 元素的添加、删除 用node.appendChild（新元素节点）将元素节点插入到node节点作为最后一个子节点；也可以用node.inserBefore（新元素节点，子参照节点）将元素插入到node的参照子节点前； 用removeChild（要移除的元素）将节点的子元素删除。 DOM0 事件和 DOM2 级在事件监听使用方式上的区别 DOM0事件是指直接将事件绑定在元素上，使用时直接定义elem.event=执行内容；在监听方式上因为是直接绑定在元素上，所以只能绑定一个事件。 DOM2级事件规定了事件的三个阶段：捕获、目标、冒泡；在js代码中使用addEventListener监听函数对元素新增一个事件侦听器，可以对一个元素添加多个侦听器；可以指定在哪个阶段触发处理程序。 attachEvent 与 addEventListener 的区别 适用的浏览器版本不同：addEventListener用于标准主流浏览器；attachEvent是针对老版本的IE浏览器。 参数数量及相应的触发阶段不同：addEventListener有三个传递参数，最后一个参数可以定义处理程序在捕获/冒泡阶段触发；而attachEvent只有两个传递参数，只能在冒泡阶段触发。 第一个参数的形式不同：addEventListener第一个参数就是事件如click；而attachEvent的第一个参数需要在前面加on如onclick; 处理程序的作用域不同：addEventListener所触发处理程序的作用域是元素本身，this指代的是触发元素和target类似；而attachEvent触发的处理程序会在全局环境下运行，this指代的是window。 在听一个事件上绑定多个事件处理程序时执行顺序不同：addEventListener会按添加顺序配合第三个参数执行；而attachEvent的执行顺序是无序的。 IE事件冒泡和DOM2事件传播机制 IE事件冒泡：事件发生在触发元素上，从触发元素开始，事件往其父元素传播，类似水中冒气泡般再一级一级往上传播，最终到html根节点。 DOM2事件传播机制：DOM2事件传播分三个阶段，捕获阶段、处于目标阶段、冒泡阶段（注意，只能选择捕获或冒泡其中的一个阶段来让处理程序执行）；用户行为或其他事件发生后，根节点最先知道，而后一级一级往下传递直到到达触发触发元素的身上，此为捕获阶段；事件到达目标元素身上，此为处于目标阶段；从目标元素身上又一层一层往上传递，直至到达根节点，此为冒泡阶段。 阻止事件冒泡、阻止默认事件 在想要截断的元素节点中的处理程序中添加e.stoppropagation( )让事件停止冒泡； 在目标元素添加仅包含e.preventDeafault( )的处理程序来阻止默认事件。","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"javascript 正则表达式","slug":null,"date":"2016-05-02T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/02/正则表达式/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"\\d，\\w,\\s,[a-zA-Z0-9],\\b,.,*,+,?,x{3},^$分别是什么?\\d是查找数字（digital）， 数字0~9会被匹配到 。\\w是查找单词（word），字母、下划线、数字都会被匹配到。\\s是查找空格（space），空格会被匹配到。[a-zA-Z0-9]查找单个在此范围内的字符，此例大小写字母和数字都会被匹配到，非全局。\\b是指词边界（border），可以用两个\\b将要匹配的字符包裹。.是指代任意字符除了回车、换行和分隔符，使用后类似模糊匹配。*是指匹配0个或多个，类似｛0，｝；+是指匹配1个或多个，类似｛1，｝?是指匹配0个或1个，类似｛0，1｝x{3}是指匹配含3个x的字符，就是xxx。^是指定整个字符串以哪个字符开头。$是指定整个字符串以哪个字符结尾。 贪婪模式和非贪婪模式 贪婪模式是指匹配时按最大可能去匹配，直到下一个字符不满足条件为止； 非贪婪模式是指匹配时按最小满足条件去匹配，只要满足条件后就不再匹配。 小练习函数trim(str)，去除字符串两边的空白字符function trim(str){ return str.replace(/^\\s+|\\s+$/g,&apos;&apos;); } var str=&quot; dddff sad dfd &quot;; str=trim(str); console.log(str); //&quot;dddff sad dfd&quot; 使用正则实现 addClass(el, cls)、hasClass(el, cls)、removeClass(el,cls)// el为dom元素，cls为操作的class， el.className获取el元素的class** function hasClass(el, cls){ var regex=new RegExp(&apos;\\\\b&apos;+cls+&apos;\\\\b&apos;,&apos;g&apos;); return regex.test(el.className); } function addClass(el, cls){ if(hasClass(el,cls)===false){ el.className += &quot; &quot;+cls; } } function removeClass(el,cls){ if(hasClass(el,cls)===true){ var regex=new RegExp(&apos;\\\\b&apos;+cls+&apos;\\\\b&apos;,&apos;g&apos;); el.className=el.className.replace(regex,&quot;&quot;); el.className=el.className.replace(/\\s{2}/g,&quot; &quot;); } } var el={className:&quot;clear btn foot&quot;}; hasClass(el,&apos;foot&apos;); // true hasClass(el,&apos;header&apos;); // false addClass(el, &apos;foot&apos;); // &quot;clear btn foot&quot; addClass(el, &apos;header&apos;); // &quot;clear btn foot header&quot; removeClass(el,&apos;btn&apos;); // &quot;clear foot header&quot; removeClass(el,&apos;hatt&apos;); // &quot;clear foot header&quot; 函数isEmail(str)，判断用户输入的是不是邮箱function isEmail(str){ return (/^[a-zA-Z0-9]\\w+@\\w+\\.\\w+/.test(str)); } 函数isPhoneNum(str)，判断用户输入的是不是手机号function isPhoneNum(str){ return (/^1[3-8]\\d{9}$/.test(str)); } 函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）*function isValidUsername(str){ return (/^\\w{6,20}$/.test(str)); } 函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，包括大写字母、小写字母、数字、下划线至少两种）function isValidPassword(str){ var i=0; if(/^\\w{6,20}$/.test(str)){ if(/[a-z]/.test(str)){ i++; }; if(/[A-Z]/.test(str)){ i++ }; if(/[0-9]/.test(str)){ i++ }; if(/_/.test(str)){ i++ }; if(i&gt;1){ return true; }else return false;; }else return false; } 写一个正则表达式，得到如下字符串里所有的颜色（#121212）var re = /#\\b[a-fA-F0-9]{3}\\b|#\\b[a-fA-F0-9]{6}\\b/g; var subj = &quot;color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee #fd2 &quot;; alert( subj.match(re) ) ; // [&quot;#121212&quot;, &quot;#AA00ef&quot;, &quot;#fd2&quot;] 下面代码输出什么? 为什么? 改写代码，让其输出hunger, world.var str = &apos;hello &quot;hunger&quot; , hello &quot;world&quot;&apos;; var pat = /&quot;.*&quot;/g; str.match(pat); // [&quot;&quot;hunger&quot; , hello &quot;world&quot;&quot;] 因为使用&apos;*&apos;默认是最大可能匹配 也即贪婪模式 //代码修改如下 var str = &apos;hello &quot;hunger&quot; , hello &quot;world&quot;&apos;; var pat = /&quot;.*?&quot;/g; str.match(pat); // 使用&apos;？&apos;让其变成非贪婪模式 补全如下正则表达式，输出字符串中的注释内容. (贪婪模式和非贪婪模式两种方法)123456789// 非贪婪模式str = &apos;.. &lt;!-- My -- comment \\n test --&gt; .. &lt;!----&gt; .. &apos;re = /&lt;!--[\\W\\w]*?--&gt;/g;console.log(str.match(re)) // &apos;&lt;!-- My -- comment \\n test --&gt;&apos;, &apos;&lt;!----&gt;&apos;// 贪婪模式str = &apos;.. &lt;!-- My -- comment \\n test --&gt; .. &lt;!----&gt; .. &apos;re = /&lt;!--[^&gt;]*--&gt;/g;console.log(str.match(re)) // &apos;&lt;!-- My -- comment \\n test --&gt;&apos;, &apos;&lt;!----&gt;&apos; 找出字符串中有效的标签123var re = /&lt;[^&gt;]+&gt;/g;var str = &apos;&lt;&gt; &lt;a href=&quot;/&quot;&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;b&gt;&apos;console.log(str.match(re)); // &apos;&lt;a href=&quot;/&quot;&gt;&apos;, &apos;&lt;input type=&quot;radio&quot; checked&gt;&apos;, &apos;&lt;b&gt;&apos;","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"javascript 闭包、定时器","slug":null,"date":"2016-05-01T06:43:41.000Z","updated":null,"comments":null,"path":"2016/05/01/JavaScript-闭包、定时器/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"闭包及其作用 闭包是能够读取其他函数内部变量的函数；相当于在草原上用栅栏单独围一片地只留一个进出口；只有通过返回出的函数才能去修改其内部的变量。 有两个作用：①读取/修改其他函数内部的变量，形成单独的一个空间，不受外部影响，可用于封装。②使其他函数内部的变量不会被销毁而始终存在于内存中。 setTimeout 0 的作用 setTimeout 0 的作用并不在于其延时0的这个字面意思，而是js对它的处理机制上；对被setTimeout包裹的代码段，不管其延时多久，都会被js放到代码的尾部，只有等其他代码执行完毕后才会按延时时间去运行其内部的代码； 根据这个特性，我们可以把需要最后执行的代码用setTimeout 0进行包裹，确保最后执行；在部分事件上，例如我需要一个div显示用户输入文本框的内容，这个时候我使用onkeydown来绑定更新输入值，当键盘被按下时开始更新输入值；但是第一次按下键盘输入时，此时js的处理结果还没出来，但由于我绑定按下这个条件就会更新输入值，所以等于第一次输入去获取更新时是空的，这样在用户看来就是我按下第二个键才显示之前输入的内容；那么我们可以怎么做呢？对，在获取更新的这个代码上加setTimeout 0 ，让其跑到js处理结果之后去更新，这样就能实时显示输入值了！ 小练习下面的代码输出多少？修改代码让fnArri 输出 ivar fnArr = []; for (var i = 0; i &lt; 10; i ++) { fnArr[i] = function(){ return i; }; } console.log( fnArr[3]() ); // 输出为10 方法1 使用闭包： var fnArr = []; for (var i = 0; i &lt; 10; i ++) { fnArr[i] = function(i){ return function(){ return i; }; }(i); } console.log( fnArr[2]() ); // 2 方法2 把i绑定到函数上 作为函数的一个属性存储起来 var fnArr = []; for (var i = 0; i &lt; 10; i ++) { var print=function(){}; print.index=i; fnArr[i]=print; } console.log( fnArr[5].index ); // 5 方法3 用两个立即执行函数返回i 赋给fnArr[i]；相当于fnArr[i]=i，数组里面放的是固定的数（好像没什么。。。但是fnArr[i]可以输出i） var fnArr = []; for (var i = 0; i &lt; 10; i ++) { fnArr[i] = function(){ return function(){ return i; }(); }(); } console.log( fnArr[7] ); // 7 使用闭包封装一个car对象var Car = function(){ var speed=0; return{ setSpeed:function (num){ speed=num; }, getSpeed:function (){ console.log(speed); }, accelerate:function (){ speed=speed+10; }, decelerate:function (){ speed=speed-10; }, getStatus:function (){ if(speed&gt;0) console.log(&apos;running&apos;) else console.log(&apos;stop&apos;) } } }(); Car.setSpeed(30); Car.getSpeed(); //30 Car.accelerate(); Car.getSpeed(); //40; Car.decelerate(); Car.decelerate(); Car.getSpeed(); //20 Car.getStatus(); // &apos;running&apos;; Car.decelerate(); Car.decelerate(); Car.getStatus(); //&apos;stop&apos;; //Car.speed; //error 使用setTimeout模拟setInterval的功能function newInterval(func,time){ //定义伪间隔函数 一个形参为‘函数’，另一个形参为‘间隔时间’ setTimeout(function(){ func(); newInterval(func,time); },time); } var i=1; function count(){ //举个例子 使用计数函数 console.log(i++); } newInterval(count,1000); 计算setTimeout最小时间粒度function min(){ var t1=Date.now(); var i=0; var clock=setTimeout(function(){ i++; if (i==5000){ clearInterval(clock); console.log((Date.now()-t1)/i); } clock=setTimeout(arguments.callee,0) },0); } min(); // 4.102 4.0982 4.0968 最小粒度应该为4ms 解释如下代码的输出var flag = true; setTimeout(function(){ flag = false; },0) while(flag){} //没有输出结果 因为setTimeout所包裹的代码将会被放到末尾执行 flag一直是true 导致循环一直在进行，后面的代码在排队等候中 console.log(flag); 下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现）for(var i=0;i&lt;5;i++){ setTimeout(function(){ console.log(&apos;delayer:&apos; + i ); // }, 0); console.log(i); // 先输出 0 1 2 3 4 ，再输出 delayer：5 } 让其输出delayer: 0, delayer:1的方法如下： for(var i=0;i&lt;5;i++){ (function(i){ setTimeout(function(){ console.log(&apos;delayer:&apos; + i ); }, 0); console.log(i); //先输出 0 1 2 3 4 再输出 delayer:0 delayer:1 delayer:2 delayer:3 delayer:4 })(i); }","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"javascript 事件对象、引用类型","slug":null,"date":"2016-04-29T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/29/JavaScript-时间对象、引用类型/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"基础类型和复杂类型 基础类型有 数值型、布尔型、字符串、null和undefined；特征是都比较简单，占用空间小使用的是栈内存类似一片规划好的整齐排列的地；变量名所在的空间里存放的就是具体值。 复杂类型有 数组、函数、对象、正则；特征是较复杂是简单类型组合而成的数据，占用空间较大，家门口的田地放不下，使用的是堆内存类似去草原圈一块地，一般变量名里存放的是指向堆内存的地址，就好像在家门口那块地放上一张去草原那块地的地图一样。 基础类型和复杂类型实践var obj1 = {a:1, b:2}; var obj2 = {a:1, b:2}; console.log(obj1 == obj2); // false obj1/2里存放的是两个不同的地址 两个地址指向两个地方 虽然这两个地方放的东西是一样的 但本质上这两个地址是不同的 console.log(obj1 = obj2); // 输出obj1 将obj2里存的地址赋给obj1后 会返回变更后的obj1 console.log(obj1 == obj2); // true obj1和obj2存的是同一个地址 两者相等 小练习函数getIntv，获取从当前时间到指定日期的间隔时间function getIntv(char){ var intv=(Date.parse(char)-Date.now()); var a=1000*60*60*24; var day=Math.floor(intv/a); var hours=Math.floor((intv-day*a)/a*24); var minute=Math.floor((intv-day*a-hours*a/24)/a*24*60); var second=Math.floor((intv-day*a-hours*a/24-minute*a/24/60)/a*24*60*60); return &apos;倒计时&apos;+day+&apos;天&apos;+hours+&apos;小时&apos;+minute+&apos;分&apos;+second+&apos;秒&apos;; } var str = getIntv(&quot;2016-05-01&quot;); console.log(str); // 倒计时7天18小时22分4秒 函数getChsDate(char)把数字日期改成中文日期function getChsDate(char){ var char=(char.split(&apos;-&apos;)); var newarr=[]; chs=[&apos;零&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;,&apos;七&apos;,&apos;八&apos;,&apos;九&apos;,&apos;十&apos;]; for(var i in char){ newarr.push(char[i].split(&apos;&apos;)); } year=chs[newarr[0][0]]+chs[newarr[0][1]]+chs[newarr[0][2]]+chs[newarr[0][3]]+&apos;年&apos;; if ([newarr[1][0]===1]){ month=&apos;十&apos;+chs[newarr[1][1]]+&apos;月&apos;; }else { month=chs[newarr[1][1]]+&apos;月&apos;; } switch (newarr[2][0]){ case &quot;0&quot;: day=chs[newarr[2][1]]+&apos;日&apos;;break; case &quot;1&quot;: day=&apos;十&apos;+chs[newarr[2][1]]+&apos;日&apos;;break; case &quot;2&quot;: day=&apos;二十&apos;+chs[newarr[2][1]]+&apos;日&apos;;break; default: day=&apos;三十&apos;+chs[newarr[2][1]]+&apos;日&apos;; } month=month.replace(&apos;零&apos;,&apos;&apos;); day=day.replace(&apos;零&apos;,&apos;&apos;); return year+month+day; } var str = getChsDate(&apos;2015-10-10&apos;); console.log(str); // 二零一五年十月十日 函数getLastNDays(num)获取n天前的日期function getLastNDays(num){ var time=new Date(Date.now()-num*24*3600*1000); return time.getFullYear()+&apos;-&apos;+time.getMonth()+&apos;-&apos;+time.getDate(); } var lastWeek = getLastNDays(7); // &quot;2016-3-16&quot; var lastMonth = getLastNDays(30); // &quot;2016-2-24&quot; 计算一段代码运行的时间var Runtime = (function(){ return { start: function(){ t1=Date.now(); }, end: function(){ t2=Date.now(); }, get: function(){ return &apos;这段代码运行的时间为：&apos;+((t2-t1)/1000)+&apos;秒&apos;; } }; }()); Runtime.start(); for (var i=0;i&lt;10000;i++) console.log(1); Runtime.end(); console.log( Runtime.get() ); // 这段代码运行的时间为：1.069秒 楼梯有200级，每次走1级或是2级，从底走到顶一共有多少种走法?function way(step){ if (step&lt;2){ step=1; }else { step=way(step-1)+way(step-2); } return step; } console.log(way(7)); // 21种方法 7级台阶 console.log(way(10)); // 89 10级台阶 console.log(way(15)); // 987 15级台阶 console.log(way(45)); // 1836311903 45级台阶 一个深拷贝的方法，运用递归function arrayCopy(obj){ var newobj=obj; for(i in obj){ if(typeof obj[i]!==&apos;object&apos;) newobj[i]=obj[i]; else{ newobj[i]=arrayCopy(obj[i]); } } return newobj; } var obj1={&quot;array&quot;:[4,5,[2,3,5,],78],&quot;name&quot;: &quot;张三&quot;, &quot;工作同事&quot;:{&quot;name&quot;: &quot;李四&quot;, &quot;habit&quot;: &quot;爬山&quot;}}; var obj2=arrayCopy(obj1); // Object {array: Array[4], name: &quot;张三&quot;, 工作同事: Object} var obj3=[4,5,[2,3,5,],78,{&quot;name&quot;: &quot;张三&quot;, &quot;工作同事&quot;:{&quot;name&quot;: &quot;李四&quot;, &quot;habit&quot;: &quot;爬山&quot;}}]; var obj4=arrayCopy(obj3); // [4, 5, Array[3], 78, Object]","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"javascript 数组、字符串、数学函数","slug":null,"date":"2016-04-28T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/28/JavaScript-数组、字符串、数学函数/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"数组方法中的push、pop、shift、unshift、join、split push是推，向数组的末尾添加一个数据；pop是拿掉，把数组中最后一个数去掉； shift是将数组的第一个数移除；unshift是向数组首位添加一个数； join是将数组里的每一项用自定义字符串接起来成一个字符串并返回，不会影响原数组；split是将字符串的以选定的字符分隔开并存储在数组中返回，也不会影响原字符串； 用 splice 实现 push、pop、shift、unshift方法 数组小练习使用数组做Html的拼接var prod={ name:&apos;女装&apos;, styles:[&apos;短款&apos;,&apos;冬季&apos;,&apos;春装&apos;] }; function getTpl(data){ var arr=[&apos;&lt;dl class=&quot;product&quot;&gt;&apos;,&apos;&lt;/dl&gt;&apos;]; arr.splice(arr.length-1,0,(&apos;&lt;dt&gt;&apos;+data.name+&apos;&lt;/dt&gt;&apos;)); for(var i=0;i&lt;data.styles.length;i++){ arr.splice(arr.length-1,0,(&apos;&lt;dd&gt;&apos;+data.styles[i]+&apos;&lt;/dd&gt;&apos;)); } return arr.join(&apos;&apos;); } var result=getTpl(prod); console.log(result); // &lt;dl class=&quot;product&quot;&gt;&lt;dt&gt;女装&lt;/dt&gt;&lt;dd&gt;短款&lt;/dd&gt;&lt;dd&gt;冬季&lt;/dd&gt;&lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; 函数filterNumeric，可以找出目标数组中的数字arr = [&quot;a&quot;, 1, &quot;b&quot;, 2]; function filterNumberic(arr){ var newarr=[]; for(var i in arr){ if((typeof arr[i]) === &apos;number&apos;) newarr.push(arr[i]); } return newarr; } warr=filterNumberic(arr); console.log(warr); addClass、removeClass函数的实现var obj = { className: &apos;open menu&apos; }; function addClass(obj,val){ newarr=obj.className.split(&apos; &apos;); for (var i=0; i&lt;newarr.length; i++){ if(newarr[i] === val){ console.log(obj.className); return ; } } obj.className=obj.className.replace(obj.className[obj.className.length-1],obj.className[obj.className.length-1]+&apos; &apos;+val); console.log(obj.className); } function removeClass(obj,val){ newarr=obj.className.split(&apos; &apos;); console.log(newarr); for (var i=newarr.length-1; i&gt;-1; i--){ if(newarr[i] === val) newarr.splice(i,1); } obj.className=newarr.join(&apos; &apos;); console.log(obj.className); } addClass(obj, &apos;new&apos;); // obj.className=&apos;open menu new&apos; addClass(obj, &apos;open&apos;); // 因为open已经存在，此操作无任何办法 addClass(obj, &apos;me&apos;); // obj.className=&apos;open menu new me&apos; console.log(obj.className); // &quot;open menu new me&quot; removeClass(obj, &apos;open&apos;); // obj.className=&apos;menu new me&apos; removeClass(obj, &apos;blabla&apos;); // 不变 将字符串首字母大写并去掉连接符‘-’function camelize(str){ var arr=str.split(&apos;-&apos;); for(i in arr){ arr[i]=arr[i].charAt(0).toUpperCase() + arr[i].slice(1); } str=arr.join(&apos;&apos;) console.log(str); } camelize(&quot;background-color&quot;); // BackgroundColor camelize(&quot;list-style-image&quot;); // ListStyleImage Sort函数依据age将对象排序var john = { name: &quot;John Smith&quot;, age: 23 } var mary = { name: &quot;Mary Key&quot;, age: 18 } var bob = { name: &quot;Bob-small&quot;, age: 6 } var people = [ john, mary, bob ] function ageSort(arr){ arr.sort(function(a,b){ return a.age - b.age; }); console.log(arr); } ageSort(people) // [ bob, mary, john ] 字符串小练习ucFirst函数，返回第一个字母为大写的字符function ucFirst(char){ char=char.charAt(0).toUpperCase()+char.slice(1); console.log(char); } ucFirst(&quot;hunger&quot;); // Hunger 函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…function turncate(str,maxlength){ if(str.charAt(maxlength)!==&apos;&apos;) str=str.slice(0,maxlength)+&apos;...&apos;; console.log(str); } turncate(&quot;hello, this is hunger valley,&quot;, 10); // &quot;hello, thi...&quot;; turncate(&quot;hello world&quot;, 20); // &quot;hello world&quot; 数学函数小练习函数limit2，保留数字小数点后两位，四舍五入function limit2(num){ num=Math.round(num*100)/100; console.log(num); } var num1 = 3.456 limit2( num1 ); //3.46 limit2( 2.42 ); //2.42 函数minMax，获取从min到max之间的随机数，包括min不包括maxfunction minMax(min,max){ console.log((max-min)*Math.random()+min); } minMax(50,100); // 93.67403362954349 73.32116993708193 51.95918010535645 函数minMax，获取从min到max之间的随机整数，包括min包括maxfunction minMax(min,max){ console.log(Math.floor((max-min+1)*Math.random()+min)); } minMax(50,60); // 57 55 53 52 54 50 函数minMax，获取一个随机数组，数组中元素为长度为len，最小值为min，最大值为max(包括)的随机数function getArr(min,max,len){ var arr=[]; for(var i=0;i&lt;len;i++){ arr.push(Math.round(1e14*((max-min)*Math.random()+min))/1e14); } console.log(arr); return arr; } getArr(50,60,3); // [50.0677831803007, 50.09292999150542, 50.07795163429897] //把随机数扩大1e14倍，四舍五入后再/1e14，当出现59.99999999999999时近似出现60","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"javascript 函数","slug":null,"date":"2016-04-27T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/27/JavaScript-函数/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"函数声明和函数表达式 函数声明和函数表达式都是创建函数的方法； 函数声明会触发函数提升，而函数表达式不会； 函数声明是一个声明不需要在大括号后面加;，但是函数表达式是一个语句，结尾需要加; 函数声明一般带有函数名以便调用，函数表达式不带函数名（如果带函数名也只是在函数内部自己调用，外部不可用）。 变量的声明前置、函数的声明前置 js的工作方式是先解析代码，提前知道所有变量的声明或函数的声明，再一行一行执行代码；这就产生了变量提升和函数提升。函数声明前置与变量前置类似，它是将整个函数提升到代码顶部，同样只有使用function声明的函数才会前置。 arguments 是什么 arguments是一个包含函数运行时的所有参数的对象；arguments[0]代表传递给函数的第一个参数，以此类推；另外可以在函数内部使用arguments[i]对参数进行修改（内部有效） 函数的重载 在弱类型语言js中，无法去构造两个同名的函数，即使它们的参数数量不同，后声明的函数会把前面的函数覆盖掉！ 但是可以通过arguments来代替不同的参数，上一问解答过，arguments包含所有传递给函数的参数，我们可以用arguments.length做判定条件，搭配任意变量来遍历每一个参数，从而达到函数重载的目的。 立即执行函数表达式 有时候我们定义一个函数后，会有立即调用的需求；那么就可以直接用一个括号把整个函数包裹起来后面紧跟着（形参）就可以让函数立刻执行，这就是立即执行函数表达式；另外它还具备表达式的一些功能，比如可以将函数返回值赋值给其他变量，也可以参与运算。 立即执行函数可以省略函数名，这样就不会影响全局；另外因为其内部是函数，就可以形成特有的作用域，可以封装一些外部无法访问的变量。 函数的作用域链 作用域：指变量存在或作用的范围，js中作用域分两种，全局作用域和函数作用域； 在函数外部声明的变量在全局都可读；在函数内部声明的外部无法读取。 注意：函数内部声明的变量会覆盖外部的全局变量（如果有的话）。 作用域链：函数也是对象，其内部有一个属性[scope]储存了这个函数可能用到的所有变量；这些变量被称为是这个函数的作用域链 创建函数时，js会将所有全局变量放入作用域链中； 调用函数时，会临时将一部分活动的对象（函数的所有局部变量、命名参数、参数集合）加入到作用域链顶端； 函数执行时，会先去作用域中寻找局部变量或命名参数等，如果找不到的话，才会进一步到全局变量中去找。","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"初始javascript","slug":null,"date":"2016-04-25T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/25/初识-JavaScript/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"CSS和JS在网页中的放置顺序 css放在文档元素的前面包含在&lt;head&gt;中，js放在文档元素的后面在&lt;body&gt;里且在尾部。 白屏和FOUC的产生 白屏和FOUC都是由于把css样式的放置在文档元素的后面造成的； 白屏：如果浏览器的工作模式是把所有的html内容和css样式都加载之后才进行呈现渲染的话；那么根据放置的顺序，首先它先加载html元素，完成之后，再开始加载css样式；在打开页面到css加载完成之前的这段时间，浏览器是不会呈现内容的，这就是白屏现象； FOUC：如果浏览器的工作模式是加载一个html元素就呈现一个，加载一个样式就渲染一个样式的话；那么根据放置的顺序，它先加载html元素，并且立刻就呈现出来，注意此时html元素是没有样式的，等html加载完开始加载css样式时，元素才会一个个突然呈现出样式；在打开页面看到元素到完成这一元素的css样式加载的这位段时间，从没有样式到突然呈现，这就是FOUC，无样式内容闪烁。 async、defer的作用与区别 async和defer的作用是让浏览器在遇到js的时候不要停止对html文档的解析。 区别在于，async异步会在js下载完成后停止html文档解析，转而开始执行下载的js，执行之后再进行html文档解析；而defer推迟指的是在下载完成后不会立刻执行，会等到html文档全部解析完成后才开始执行。 网页的渲染机制 ①根据用户的访问请求去获得网站的资源，html文档、css样式、js文档等；②将html文档进行解析排布，得到树状结构的html链，就是DOM树；③将css文档进行解析排布，得到树状结构的ccs链，就是CSSOM树；④将DOM树和CSSOM树结合生成Render渲染树；⑤进行layout布局，确定各个节点位置；⑥按layout进行绘制，显示页面。 JavaScript 中的数据类型 Javascript 定义了6种数据类型：①数值（number），如整数1、2、3和小数2.5等；②布尔型（boolean），就真（true）和假（false）两个值；③字符串（string），一串文本可以是字母也可以是数字，也可以是字母+数字；如”345”、”hi”、”abc123”等；④null，表示目前是个空值；⑤undefined，表示不存在，目前没有值；⑦对象（object），其他各种值组成的一个集合； 上述的数值、布尔型、字符串三种是简单类型，对象是其他值组成的集合是复杂类型，null和undefined是两个特殊的值。 NaN、undefined、null是什么 NaN 是 Not a Number即不是一个数的意思，代表将要操作的对象不是一个数； undefined是不存在的意思目前没有值，定义后未赋值就会提示undefined；注意区分 not defined 是未定义！ null表示目前是个空值； typeof 和 instanceof 的作用和区别 typeof 是用来确定一个值是什么类型的，例如typeof 123，就会返回number,它的返回值包括三种简单类型、函数、undefined和对象； instanceof是用来确定一个对象是否是某个构造函数的实例，可以用来判断值的类型，例如[1,2,3] instanceof Array,它会返回true说明[1,2,3]是属于数组的一个实例，它的左边放置对象，右边放置构造函数； 区别在于typeof右边放置某个值，它会告诉你这个值是属于什么类型的；而instance是用来确定对象是否是某个构造函数的示例，依据这个特性可以用它来判断值属不属于某个类型，它的左边只能是对象不能直接简单类型的数值。","raw":null,"content":null,"categories":null,"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"浏览器兼容","slug":null,"date":"2016-04-19T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/19/浏览器兼容/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"在 IE 浏览器上进行调试 在高版本的IE浏览器如IE8以上，有开发者工具，按F12调出，可以选择不同的浏览器版本进行调试（除了IE6，IE6可以通过设置border或使用javascript来测试）。 CSS hack的含义及在 CSS 中 ie6、ie7的使用 CSS hack是CSS使用中的一些奇怪的做法(与现行的标准用法不同，早期的浏览器如IE6出来时并没有统一的渲染标准)，主要是针对低版本的IE浏览器的兼容性来使用的。 在HTML中hack的写法一般有三种①属性前缀：直接在CSS选择器内部的属性前加仅低版本IE能识别的符号* _等；IE6能识别* _,例如*display：inline；而IE7能识别*但不能识别_。②选择器前缀：在CSS选择器前加仅低版本IE能识别的符号；IE6能识别*，如*p{}；而IE7能识别*+，如*+p{}③条件注释:针对一大段的CSS hack可以用&lt;!--[if IE]&gt;请书写针对IE浏览器的内容&lt;[!end if]--&gt;来做兼容，if IE可以改成其他条件，如if IE6等 常见浏览器兼容问题 不支持部分标签或属性：例如IE6不支持display:inline-block,因为其内部没有关于此属性的定义和解析方式，这个时候我们就只能退而求其次使用display:inline来保证至少排版不要差异太大，当然也可以用其他方式如浮动来达成类似的效果，同样的例子还有min-height等. 不同浏览器的默认设置差异：例如低版本的IE盒模型与标准盒模型的差异（下面问题会提到）；又或者默认的margin和padding差异，所以一般在css来头会有一个*通配符来修改默认的的margin和padding为0。 对兼容、多浏览器覆盖的看法及渐进增强和优雅降级的理解 兼容和多浏览器覆盖是历史遗留问题，是在浏览器发展和W3C标准的建立中逐渐产生的，我认为开发人员需要抓住主要需求，针对主浏览器做开发，最后再去做兼容和多浏览器覆盖，要分清主次，明白锦上添花的含义。最终前端开发人员理想的状况是不需要兼容；针对前端入门的新手我认为重点在学习其他重点知识，对兼容是要去理解，也要知道如果碰到此问题要如何去搜索寻找解决方法，保持有意识也懂方法的前提下先去补充其他知识。 渐进增强、优雅降级的主要思想是一样的，就是先指针对需求，适配1~2款浏览器去做主开发。如果是先针对现代浏览器的话，就可以优雅降级，不追求画面多炫功能多强大，针对低版本如IE7等做些兼容能实现基础功能即可；而如果一开始是部分政府项目，是针对IE6、7等低版本浏览器做的开发的话，就可以渐进增强，针对现代浏览器修改部分CSS去实现一些相对较先进方便的功能把页面做得更漂亮一点。 reset.css和normalize.css的作用与区别 reset.css是用于去除浏览器预先给标签设置的默认样式，如h标题的加粗和margin、li前面的小圆点等，有时候我们并不需要这些默认设置，就可以在CSS开头进行CSS重置，就是reset.css。 normalize.css是reset.css的改良版，他是在reset的基础上进行改良避免误伤，保留了一些有价值的默认样式，还增加了其他功能，也没有reset.css的一些缺点。 相比与reset.css，normalize.css有以下几个优点：①它保留了部分有价值的默认样式，而且努力使不同浏览器的默认值保持一致尽量让表现接近现代标准；②它修复部分浏览器的问题和bug（目前我还不大理解）；③它没有reset.css的长串继承链，调试的时候不会显得很乱；④它是模块化的，你可以清楚地知道哪些元素设置了什么值，同时你可以去掉某些你不常用或你不想要的部分；⑤它有详细的代码和注释文档，你可以自己测试，同时也能让你了解到浏览器默认是怎么渲染元素的。 IE盒模型和标准盒模型的区别，怎样使 IE678使用标准盒模型?box-sizing:border-box的作用？ 盒模型，最中心是内容,往外是paddin内边距，再来是border边框,最后是margin外边距；IE盒模型和标准盒模型构造一样，区别在于当你指定了一个块级元素的width值后，在标准盒模型中代表内容宽度，而同一个width值在IE盒模型中却是内容宽度+内边距+边框，引用一张图作说明： 可以使用&lt;!doctype html&gt;声明来使 IE678使用标准模式的标准盒模型。 box-sizing:border-box使用后，为元素指定的宽度和高度将包含其内边距和边框，后续如果有设置内边距和边框的话就会压缩内容宽度了，想当于采用了怪异IE盒模型。 在 ie 6, 7, 8中盒模型的展示 IE6的测试如下，没有doc申明，IE盒子，盒子偏小，不支持inline-block、不支持max-width! 我们把doc申明添加进去，并在IE6做测试，盒子变回标准盒模型，但是inline-block和max-width依然没有效果！ IE8测试如下，没有doc申明，IE盒子，盒子偏小，未申明doc不支持inline-block、未申明也不支持max-width! 我们把doc申明添加进去，并在IE8做测试，盒子变回标准盒模型，也支持inline-block和max-width！ chrome浏览器效果如下，标准盒子，支持inline-block、支持max-width！","raw":null,"content":null,"categories":null,"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"负边距及三栏布局","slug":null,"date":"2016-04-18T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/18/负边距及三栏布局/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"负边距在让元素产生偏移时和position: relative的区别 负边距产生偏移是改变元素的外边距，从而引起元素在文档流中的布局位置的改变。 position: relative产生偏移时元素在文档流中的布局位置并没有改变，只是其外观表象相对于自身原本的位置做一个偏移，是不会影响其他元素的布局的，但会遮挡其他元素。 使用负 margin 形成三栏布局的条件 中间main设为浮动宽度100%，两个side也要设为浮动宽度定好，外部容器ct清除浮动； 两个side使用负margin（一个为-100%，另一个为-‘自身宽度’）分别移动到main的左右两边； 若为圣杯三栏，则需设置main区块的padding留出左右空间，再使用relative将左右sider各做一个自身宽度的偏移； 若为双飞翼三栏，则需在main区块下增加一个真实的主内容div，并为此div设置左右margin。 圣杯布局的原理及实现步骤 圣杯布局的原理是利用负margin让两个浮动的固定宽度盒子进入到一个同样是浮动且自适应宽度的盒子里面去，再用相对偏移做调整，步骤如下： ①一个宽度100%的盒子main浮动并设置padding做自适应主区块； ②另外两个宽度固定的盒子side浮动并使用负margin分布于主区块的两边； ③最后让两个side盒子做相对偏移到达main留出的空padding区。 双飞翼布局的原理及实现步骤 圣杯布局的原理是利用负margin让两个浮动的固定宽度盒子进入到一个同样是浮动且自适应宽度的盒子里面去，再内嵌一个div做真正的主内容区块，步骤如下： ①一个宽度100%的盒子main浮动； ②另外两个宽度固定的盒子side浮动并使用负margin分布于主区块的两边； ③在main区块内再内嵌一个真实的主内容div，并为此div设置左右margin。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"inline-block、BFC、边距合并","slug":null,"date":"2016-04-17T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/17/inline-block、BFC、边距合并/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"外边距合并及破解方法 同一个BFC中常规文档流的两个在垂直方向“相邻”的块级盒子会出现外边距合并。 两个外边距都是正数时取其中最大的那个作为外边距；一正一负时则相加作为之间的外边距；都是负数时取其中绝对值较大的作为之间的外边距。 创建新的BFC、脱离文档流、用bordr/padding将其分隔开。 去除inline-block内缝隙的几种常见方法 相邻的标签不要有空格，可以把结束符放在下一行标签的前面； 使用负margin，一般是margin: -4px; 父容器设置font-size: 0，并重新设置子元素字体撑开高度； 也可以用浮动代替inline-block，注意清除浮动。 父容器使用overflow: auto| hidden撑开高度的原理 原本因浮动或定位导致的子元素与父容器不在同一个维度，因为使用overflow: auto| hidden后，父容器就形成了一个新的BFC，里面的布局不会受到外面元素的影响，BFC内的元素重新按顺序一个个排列，撑开高度。 BFC的形成及其作用 BFC是块级格式上下文，是一个独立的布局区间，其内部的元素排列不受外部元素影响。 浮动、绝对定位、非块级盒子的块级容器（inline-block、table cell、table caption）以及overflow值不为visible的块级盒子都可以形成BFC。 形成BFC就形成了一个独立的区间，不会受外部元素的影响；可以用来清除浮动造成的不良影响、去除外边距折叠。 浮动导致的父容器高度塌陷的原理及解决方法 指的是因为子元素浮动，因而就脱离了文档流，未设置高度的父容器认为子元素不存在，所以父容器高度会坍塌，从而影响排版显示。 ①在浮动元素的后面加一个空元素并clear:both，虽然父容器无法感知浮动元素，但是空元素能告诉他高度应该撑到哪，用空div或空内容的：after都可以，注意display:block。②可以用浮动、绝对定位、overflow：hidden/auto、display：inline-block等创建新的BFC，形成独立布局空间，让父元素感知浮动的子元素。 用伪类去撑开父容器高度（消除浮动影响）12345678.clearfix:after&#123; content: &apos;&apos;; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; BFC是独立布局空间，不受外部元素影响，重新感知浮动的元素撑开空间；而空内容的伪类是以clear作为媒介，感知到浮动元素，再以自身为截止点让父容器撑开高度。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS浮动与定位","slug":null,"date":"2016-04-16T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/16/CSS浮动与定位/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"文档流的概念，如何让元素脱离文档流 文档流指的是浏览器按照html的内容按顺序解析并呈现，遇到行内元素就往行内放，遇到块级元素就空一行放置，依次排列； 定位中的fixed、定位中的absolute、浮动都可以让元素脱离文档流。 定位方式简介 有static、fixed、absolute、relative这四种定位方式； static是静止，不进行定位，元素还是处于正常的文档流中，忽略上下左右的偏移和z-index声明，是默认值。 fixed是把元素固定住，是相对于浏览器来定位的，会脱离文档流，可以使用left、right、top、bottom来改变固定的位置；一般用于广告、一些固定提示栏等你想要固定持续显示的内容。 absolute是相对于上一个使用定位（static除外）的祖先元素进行定位的，如果没有使用定位的祖先元素，就相对于html文档页面进行定位，会脱离文档流，同样使用left、right、top、bottom来设定偏移的位置；一般用于使用相对位置的场景，在父元素上加个relative，在给子元素设定absolute进行相对偏移。 relative是相对于元素自身在文档流中的位置进行偏移的，注意它并不会脱离文档流，使用left、right、top、bottom来设定相对偏移的位置，一般用于微调整元素自身位置。 absolute, relative, fixed 偏移的参考点 absolute, relative, fixed偏移的参考点分别是上一个使用除static以外定位的祖先元素（若没有找到，则相对于html元素即文档）、元素自身原本在文档流中的位置、浏览器窗口。 z-index 的使用 可以设定元素的堆叠顺序（可以理解为Z轴高度，越高离我们视野就越近，高度比它小的就被盖住了），值越大，堆叠优先级越高；使用时将你所要展示出来的元素的z-index值设得比其他遮挡它的元素的值大就可以。 position:relative和负margin使元素位置发生偏移的区别 position:relative是单单把作用到的元素进行一个位置偏移，而其他的元素不会因此发生位置的改变；而负margin是调整外边距，这样会影响到它周围元素布局和位置。 让一个固定宽高的元素在页面上垂直水平居中 用position: absolute设置这个元素相对于页面的top和left为50%，此时该元素的左上角这个点就垂直水平居中了，之后再用-margin让其往左、往上分别移动其宽高的一半，达到垂直水平居中的目的。 浮动元素的特征及对其他元素的影响 浮动元素会脱离文档流，不占据空间； 其他浮动元素跟它处于同一层，会紧挨着它的边框放置，如果有其他元素有清除浮动，则会另起一行放置； 普通元素因它脱离文档流，所以会认为它不存在，会顶上它的位置，所以普通元素的一部分会被挡住； 文字遇到浮动元素边框会避开另起一行有环绕效果。 清除浮动 清除浮动指的是用clear属性来设置是否允许它自身周围存在浮动元素，这样可以让浮动元素因被排斥或排斥其他浮动元素而再往下占据一行，从而消除对其他元素的影响；可以设置clear：left、right、both来选择不允许哪一边存在浮动元素。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS常用技巧","slug":null,"date":"2016-04-15T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/15/CSS常用技巧/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"CSS Sprite(雪碧图|精灵图) 雪碧图指的是将一些较小的图标或其他小图片集合到一起成为一张大图，只需一次网络请求，在呈现时只需要用区块视窗和position搭配显示需要的图标，避免重复的网络请求减少资源损耗缩短等待时间。 img标签和CSS背景的区分 img标签一般用于需要链转(用a链接包裹)或需要改变图片的场景使用； 而对于部分仅仅是呈现视觉效果，如小装饰、标志等基本固定不变的场景一般使用CSS背景图。 title和alt属性的作用 title是a标签中对于将要跳转过去的页面的内容做一个概述、提示；alt属性是img标签中当因为网络状况不佳或因其他原因导致图片无法加载时，代替图片用文字说明图片内容。 background: url(abc.png) 0 0 no-repeat;的含义 意思是加载一个背景图，地址是当前目录下的abc.png，其水平位置和垂直位置为0px(相对左边和上边的偏移量为0)，图片不重复显示。 background-size的作用 可以来调整背景图的大小；IE8及一下版本不支持，opera mini 8部分支持，其他浏览器支持； 常用的值有XXpx XXpx直接指定图片大小;XX% XX%设定相对于视窗区块的百分比大小;contain将图片进行缩放，直至视窗能完整显示图片的最大大小；cover将图片进行缩放，直至图片能完全覆盖视窗的最小大小。 让一个div水平居中，让图片水平居中 让div元素的左右margin相等，即margin：0 auto(要有doc); 用一个div块级元素去包裹这个图片，再用text-align:center让块元素里的图片居中。 元素透明度的设置 可以使用opacity:0~1来设置元素的不透明度；IE8部分支持，其余浏览器支持此属性，IE8及更老版本可使用filter:alpha(opacity=0~100)来达到一样的效果。 对于部分可以设置颜色的元素可以使用rgba设置颜色，其中的a即alpha设置0.0~1.0来确定元素颜色不透明度也就达到了设置元素不透明度的目的；IE9以上及其他浏览器都支持rgba。 opacity 和 rgba在透明度设置上的区别 opacity是直接设置元素的透明度泛用性更强，而rgba是针对部分可以设置颜色的元素通过改变颜色的透明度来让元素也达到透明的效果。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS选择器","slug":null,"date":"2016-04-14T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/14/CSS选择器/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"CSS常见选择器的类别 有①通用选择器②标签选择器③id选择器④类选择器⑤属性选择器 ⑥分组选择器(多元素) ⑦派生选择器(后代)⑧子元素选择器 ⑨伪类选择器 选择器的优先级 针对性越强则其优先级就越高;内联样式&gt;id选择器&gt;伪类选择器&gt;属性选择器&gt;类选择器&gt;元素选择器&gt;通用选择器. class 和 id 的使用场景 class有普遍性一般在内部用来定义部分有共同特性的元素的样式；id是唯一的，一般用于外部划分区块。 使用CSS选择器时命名空间的划定 在html中，部分标签如p、li等使用频繁，如果没有划分区块划定命名空间，在选取时就会导致混乱，一个选择器可能会选取到所有的元素，我们就没办法针对部分元素修改其样式；划定命名空间后，就有针对性。 CSS选择器示例1234567#header&#123;&#125;.header&#123;&#125;.header .logo&#123;&#125;.header.mobile&#123;&#125;.header p, .header h3&#123;&#125;#header .nav&gt;li&#123;&#125;#header a:hover&#123;&#125; #header 选择id为header的元素 .header 选择class为header的元素 .header .logo 选择header这个类下的属于logo这个类的元素 .header.mobile 选择同时标记有header和mobile这两个类的元素 .header p, .header h3 选择header这个类下的p元素和h3元素 #header .nav&gt;li 选择header这个id下的标记有nav类的第一代li元素 #header a:hover 选择header这个id下的a元素，修改鼠标悬停在上面时的样式 常见伪类选择器 :hover 鼠标悬停时的样式；:active鼠标按下保持的样式；:focus在输入框选中时的样式；E:first child 选择E元素，且该E元素是第一子元素；E:first-of-type 选择E元素，且该E元素是同类标签的第一个。 :first-child和:first-of-type的区别 E:first child 选择E元素，且该E元素是第一子元素，在一个父元素下有多个同类子元素的情况下可以用其选择第一个子元素； E:first-of-type 选择E元素，且该E元素是同类型标签的第一个；在一个区块内有多个同类型标签的情况下用来选择其中的第一个； 选择器及样式示例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;first-child vs first-of-child&lt;/title&gt; &lt;style&gt; .item1:first-of-type&#123; background: red; &#125; .item1:first-child&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;item1&quot;&gt;111&lt;/div&gt; &lt;div class=&quot;ct&quot;&gt; &lt;p class=&quot;item1&quot;&gt;222&lt;/p&gt; &lt;div class=&quot;item1&quot;&gt;333&lt;/div&gt; &lt;div class=&quot;item1&quot;&gt;444&lt;/div&gt; &lt;div class=&quot;item2&quot;&gt; &lt;div class=&quot;item1&quot;&gt;555&lt;/div&gt; &lt;div class=&quot;item1&quot;&gt;666&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 输出红色背景解析：111是body下两个div类型的第一个；222是标记ct类这个div下的p类型的第一个；333是标记ct类这个div下的div类型的第一个；555是标记item2类这个div下的div类型的第一个。 输出蓝色字体解析：111是body父元素下第一个div子元素；222是标记ct类这个div父元素下的第一个p子元素；555是标记item2类这个div父元素下第一个div子元素。 text-align: center的作用解析 作用在块级元素上，让块级元素里面的行内元素水平居中。 属性兼容性的查询 在caniuse.com输入属性名称查询","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS列表及表单","slug":null,"date":"2016-04-13T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/13/CSS列表及表单/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"有序列表、无序列表、自定义列表的使用及语义上的区别 三种列表按其字面意思理解使用即可；当制作的列表需要体现顺序时就使用有序列表，反之就可使用无序列表，针对较复杂或嵌套较多的则可以使用自定义列表结构更清晰明了。三者都可以嵌套，例子见下图： 列表前面的点或者数字的去除 对列表元素li使用样式｛list-style:none｝去除 class 和 id 的区别 不同元素可标记为同一个类，但id是唯一的；id更有针对性，优先级比class高。 开发者认为特殊的元素或其他独特功能的元素可使用id来标记；对于一些具有相同属性或共同特性的元素可使用class类标记。 块级元素、行内元素简介 块级元素，即单独占据页面的一行，浏览器会另起一行来放置一个块级元素，它可以容纳其他块级元素和行内元素，可以设置自身宽高，内外边距的设置有效，&lt;p&gt;、&lt;div&gt;、&lt;h1&gt;、&lt;table&gt;、&lt;form&gt;都是常见的块级元素。 行内元素，即只占据它本身内容大小的宽度，高度line-height控制（不能设置自身宽度和高度，设置内外边距后仅水平方向有效），可以和其他行内元素放在同一行内，一般它的内部只能放置其他行内元素，常见的行内元素有&lt;a&gt;、&lt;img&gt;、&lt;q&gt;、&lt;input&gt;。 display: block、display: inline、display: inline-block的作用 display: block让行内元素转变为块级元素，具有块级元素特性；设置宽高、内外边距等。 display: inline可以让快级元转变为行内元素，具有行内元素的特性；让其可以与行内元素放在一起。 display: inline-block可以让元素同时具有行内和块级元素的特性；可以与其他行内元素放在同一行，又是呈块状显示，进行块级元素的设置。 HTML CSS 语义化的理解 HTML和CSS是指页面的结构和样式，同样的页面其背后的代码可能并不相同，同一个效果我有多种实现方法；语义化是指按照大众通俗的做法来划分结构，命名类或id名称，想呈现什么效果就使用对应的元素，同样的当看到对应元素就可以知道这边的代码是属于哪个结构要呈现什么效果；语义化会方便页面的团队开发和合作，对搜素引擎和屏幕阅读器使用者也更加友好。 form表单的作用及常用input 标签 form表单是用于页面内容的输入，与后台服务器交互传输数据的。常用的input标签有radio、checkbox、text、password、submit和reset，作用分别是单选框确定相关信息、多选框选择相关信息、文本一般用于输入用户名等少量文本、密码框用于输入密码、生成提交按钮点击后往后台传输form信息、生成重置按钮重置输入的信息。 post 和 get 方式的区别 post一般用于数据量较大的数据传输，数据大小看服务器承受能力，是秘密传输，安全。 get一般用于数据量较小的数据传输，数据大小受浏览器输入框限制，在URL中可以看到提交内容，不安全。 在input中name的作用 告诉后台服务器，我给你的是什么数据。 三种提交按钮的区别&lt;button&gt;提交&lt;/button&gt;、&lt;a class=&quot;btn&quot; href=&quot;#&quot;&gt;提交&lt;/a&gt;、&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;button&gt;提交&lt;/button&gt;从显示效果上看只是一个写着提交的按钮，没有其他效果。 &lt;a class=&quot;btn&quot; href=&quot;#&quot;&gt;提交&lt;/a&gt;则是一个a链接，提交是它的链接点，点击后会留在原页面，其类是btn。 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;是一个form表单的提交按钮，点击它可以将所填的表单信息传输给后台。 表单中radio 如何 分组 具有相同name的radio就分为同一组 表单中placeholder 属性及作用 会在输入框内呈现灰色字，来提醒用户输入正确的内容。 type=hidden隐藏域的作用 type=hidden此种类型不会在页面上呈现，可以用来暂存接口的信息或地址，比如标记id快速定位然后获取存在这的接口地址；也可以用来做安全校验，比如说设置name=&quot;secret&quot; value=“123”，只有当你登录后才能打开这个页面，在这个页面进行提交时才会附带的传输这个隐藏的name和value，服务器可以以此来判断是否是本人操作从而确定是否接受请求。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS的引入","slug":null,"date":"2016-04-12T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/12/CSS的引入及个别混淆点/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"CSS样式的引入方式及link和@import的区别 样式有3种引入方式：①外部式：在&lt;head&gt;下使用link或@import引入xx.css文件。②内部式：在&lt;head&gt;下使用&lt;style&gt;书写。③内联式：在对应标签的起始符中直接添加style样式。 link和@import有以下区别：（一般使用link）①link的css载入与页面加载同步；而@import的css是在页面加载完成后引入的。②link无兼容性问题；而@import是CSS2.1时提出的，部分低版本浏览器不支持。③link支持使用Javascript控制DOM去改变样式；而@import不支持。④link还可用于定义RSS等其他事务；而@import只能用于加载css。 文件路径../main.css 、./main.css、main.css的区别 ../main.css是指上一级目录中的css文件，而./main.css、main.css都是指本目录下的css文件。 在调试中console.log的作用 console.log是用于调试Javascript用的，一步步追根溯源让控制台打印出对应数据，查看是否则正确，找出问题的关键点。相比于alert，console能显示具体内容、且不打断页面、也可在控制台显示其他内容。 text-align: justify是什么 text-align: justify是让文本两端对齐的属性，通过调整字间距让两端对齐。 px、em、rem三者的区别 3个都是字体大小的“单位”，与数字结合定义字体大小，但有区别。 px的大小是相对于显示分辨率而言的、em的大小则是相对于其父元素而言的、rem的大小是相对于根元素而言的。 chrome 审查元素的功能简介：","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Html基础","slug":null,"date":"2016-04-11T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/11/Html基础/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"网页乱码的问题及解决方法 当编写的html文档保存时的编码方式与浏览器打开此文档所使用的解码方式不匹配时，就可能出现乱码的问题； 在html文档的&lt;head&gt;中使用&lt;meta charset=&quot;编码方式&quot;&gt;，来告诉浏览器此文档的编码方式，让浏览器使用对应的解码方式解码展示此文档，解决乱码问题。 CSS中颜色的定义方式 第一种 RGB数值写法，如rgb(255,255,255),根据红绿蓝三色数值配比来呈现不同颜色。 第二种 二进制写法，如#ffffff,即将0-255的数值采用十六进制表示，十六进制的ff代表十进制的数值255，同样根据红绿蓝三色配比来呈现颜色。 第三种 对于某些特定配比的颜色，可以用对应的具象化的单词来写，例如红色，可直接用英文单词red来写。 doctype html 的作用 &lt;!doctype html&gt; 是html的文档类型申明，它告诉浏览器此文档是以html5的规范编写的，并让其以html5的标准规范去呈现这个页面。 严格模式和混杂模式 严格模式指的是：有文档类型申明，浏览器按所申明的标准和规范去渲染呈现页面， 混杂模式指的是：有部分网页是在html和css标准定义完成之前就被开发出来的，一些网页浏览器为了维持对较旧的网页设计的向后兼容性，所使用的一种技术，以期能正常渲染呈现那些非标准化的页面。 CSS头中meta 的常见值及其作用 &lt;meta&gt; 元素可提供有关页面的元信息（meta-information）,比如针对搜索引擎和更新频度的描述和关键词； 常见的值有name（关键词、站点描述、制作者）和http-equiv（主页制作的文字及语言、指定时间跳转、网页过期等）。 常见的浏览器及其内核 常见的浏览器有：Chrome、IE、Safari、Opera、Firefox 其对应的内核是：Blink、Trident、Webkit、Presto、Gecko","raw":null,"content":null,"categories":null,"tags":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}]},{"title":"初识前端","slug":null,"date":"2016-04-10T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/10/初识前端/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"前端工程师的主要工作内容：依据设计图，完成页面的实现和交互功能。 前端工程师主要做的事情：①页面实现 ②页面维护更新 ③页面优化 互联网公司产品流程：①产品经理（PM/PD）可行性调研，提出需求；②产品经理与UE（视觉、交互设计师）确定视觉交互稿；③RD（前端、后端or无线开发工程师）配合开发产品；④QA（测试工程师）对产品进行专门测试；⑤OP（运维工程师）将通过测试的产品发布上线并维护。","raw":null,"content":null,"categories":null,"tags":[{"name":"关于前端","slug":"关于前端","permalink":"http://yoursite.com/tags/关于前端/"}]},{"title":"CSS的a标签及display","slug":null,"date":"2016-04-09T06:43:41.000Z","updated":null,"comments":null,"path":"2016/04/09/CSS的a标签及display/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"line-height的作用 设置元素行高；之前的学习中有用它来调整行间距，在单行文本中当其与height相等时可实现垂直居中。 CSS属性的兼容性查询方式 打开caniuse.com输入需查询的属性名；inline-block的兼容性见下图： a 标签的href, title, target a标签的href是指超文本引用，其内容是要跳转的链接目标； title是当鼠标悬停在a链接上时，显示的对将要跳转的链接的关键词或缩略提示； target是告诉浏览器在哪里打开a链接，可用_blank在新窗口打开，还可标记id打开页面直接定位到对应id； title是对a链接跳转目标的文字注释补充，并不能代替链接内容；而alt是img元素在网络卡顿或加载失败时显示的用于代替图片内容的信息，对搜索引擎和屏幕阅读器很友好。 在a链接的目标地址后添加 target=“_blank” ，如&lt;a href=&quot;链接地址&quot; target=“_blank” &gt; display: none , visibility: hidden, opacity:0 的作用及区别 display: none是让元素消失，不会出现在页面上，没有空间，但在dom结构树中还是有。 visibility: hidden是指隐藏起来不显示，但在页面上会留空间，相当于它在那里，但是看不到。 opacity:0是指透明度为0，它在页面上也有空间，只不过它是透明的看不见而已。","raw":null,"content":null,"categories":null,"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]