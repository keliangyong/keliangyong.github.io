<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kely&#39;s Blog | 个人学习记录博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="undefined">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Kely's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Kely's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kely's Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Kely&#39;s Blog" type="application/atom+xml">
  
  <meta name="summary" content="null">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/head.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">柯良勇</h5>
        <a href="mailto:undefined" title="ke_liang_yong@163.com" class="mail">ke_liang_yong@163.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/keliangyong" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Kely&#39;s Blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Kely&#39;s Blog</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Kely&#39;s Blog</h1>
    <h5 class="subtitle">个人学习记录博客</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <ul class="post-list">
  
    <li class="post-list-item">
  <article id="post-模块化：require-js及r-js基础" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/22/模块化：require-js及r-js基础/">模块化：require.js及r.js基础</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
</div>
        <time datetime="2016-05-22T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-22
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="require-js的基本配置文件格式如下："><a href="#require-js的基本配置文件格式如下：" class="headerlink" title="require js的基本配置文件格式如下："></a>require js的基本配置文件格式如下：</h4><pre><code>requirejs.config({
  baseUrl: &quot;src/js&quot;,  
  paths: {
    &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos;
  }
});
</code></pre><p><code>baseUrl作用</code>：给后续所引用的模块自动添加一个前缀，也就是说后续所引用的模块的地址是在此url基础上加引用时的小部分路径构成的。<br><code>baseUrl的基准</code>：以引用<code>config</code>的那个<code>html</code>文件的所在目录为基准。<br><code>paths的作用</code>：为一些<code>跨baseUrl目录</code>或<code>在当前目录下路径较长</code>的模块做路径设置，在引用有设置<code>paths</code>的模块时，会用<code>baseUrl+paths</code>作为路径去获取模块。<br><code>paths的用法</code>：例如，大部分模块在<code>module</code>中，而我的<code>jquery</code>因为分类是库，所以放在<code>lib</code>下了，此时<code>baseUrl</code>兼顾大众需求设为<code>&#39;js/module&#39;</code>，而对于<code>jquery</code>因为不在<code>module</code>下所以我在paths中单独给它设路径为<code>&#39;../lib/jquery&#39;</code>。</p>
<pre><code>requirejs.config({
    baseUrl:&apos;js/module&apos;,
    paths:{
        jquery:&apos;../lib/jquery&apos;
    }
});
</code></pre><h4 id="r-js-的打包配置文件格式如下："><a href="#r-js-的打包配置文件格式如下：" class="headerlink" title="r.js 的打包配置文件格式如下："></a>r.js 的打包配置文件格式如下：</h4><pre><code>({
    baseUrl: &quot;./src/js&quot;,
    paths: {
        &apos;jquery&apos;: &apos;lib/bower_components/jquery/dist/jquery.min&apos;
    },
    name: &quot;main&quot;,
    out: &quot;dist/js/merge.js&quot;
})
</code></pre><p><code>baseUrl</code>：这个<code>baseUrl</code>是基础路径，它的任务是搭配paths或下方name、out的路径来找到对应的模块、解析起始点（即name）、输出位置（即out），它是以自身所在目录为基准的。<br><code>name</code>：是解析入口，搭配上面的<code>baseUrl</code>拼接出路径，拼接出的路径要指向<code>require.js</code>的配置文件；图中的解析入口就是<code>&quot;./src/js/main.js&quot;</code>，从<code>main.js</code>开始解析打包。</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/22/模块化：require-js及r-js基础/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-模块化：常见规范" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/21/模块化：常见规范/">模块化：常见规范</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
</div>
        <time datetime="2016-05-21T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-21
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="什么是模块化？为什么要模块化？"><a href="#什么是模块化？为什么要模块化？" class="headerlink" title="什么是模块化？为什么要模块化？"></a>什么是模块化？为什么要模块化？</h4><p><code>命名冲突</code>：为了方便也避免重复造轮子，我们习惯于把一些通用的、底层的工具抽离出来，例如写成一个函数放在另一个文件中，我们需要的时候再去引用就可以；但是在工具中被定义的变量我不能在当前文件使用，因为会产生冲突导致工具无法正常使用。所以我们希望这个工具能是一个独立的空间，不要影响到当前页面的开发。<br><code>文件依赖</code>：当我们在写一个新工具的时候，有可能会需要调用其它功能更小的工具；那么在执行时因为js的同步特性，要使用这个新工具就必须要先加载小工具，也就是说小工具要先于新工具去引入；当引入文件较多或者顺序乱了之后维护起来非常困难。<br><code>原因</code>：使用模块化主要是为了解决两个问题：命名冲突和文件依赖。<br><code>模块化x命名冲突</code>：用面向对象的方式将方法、工具绑在对象上；约定用关键字<code>exports</code>暴露接口返回对象。<br><code>模块化x文件依赖</code>：约定关键字<code>require</code>来获取对象将文件依赖内置，不需要外部引入。</p>
<h4 id="CMD、AMD、CommonJS-规范分别指什么？"><a href="#CMD、AMD、CommonJS-规范分别指什么？" class="headerlink" title="CMD、AMD、CommonJS 规范分别指什么？"></a>CMD、AMD、CommonJS 规范分别指什么？</h4><p><code>Common JS</code>：它是一个规范，它通过定义丰富的能解决一些通常的应用开发需求的API来补足了<code>js</code>官方关于标准库的不足。建立它的意图是希望开发者可以运用这些API去开发应用，而且所开发的应用能够在不同的js环境中运行而不仅仅是浏览器。服务器端的<code>javascript</code>应用<code>node.js</code>就是运用<code>Common JS</code>的一个例子，服务器端的程序比浏览器端要更复杂，也需要与操作系统和其他程序互动，因此服务器端必须要模块块以便应对上述问题。<code>node.js</code>参照<code>Common JS</code> 规范创建了模块系统，模块系统通过<code>exports</code>暴露接口返回对象，通过<code>require</code>获取接口返回的对象。例如</p>
<pre><code>// math.js文件 的内容：
 exports.method=function(){
  var obj=xxx;
  // doing something
  return obj;
 };

 // main.js文件 的内容：
 var newObj= require(&apos;math&apos;).method;
 // 当然 main.js可以继续exports接口 以供其他文件调用
</code></pre><p><code>AMD</code>：<code>&quot;Asynchronous Module Definition&quot;</code>即异步模块定义，实现AMD的库有<code>RequireJS</code> 、<code>curl</code> 、<code>Dojo</code> 等。在服务器端采用的<code>Common JS</code>规范到浏览器端因为同步执行加载的问题会导致浏览器在加载获取时处于假死状态什么都不能做只能等引用加载完，<code>AMD</code>在这种环境下诞生了；<code>AMD</code>采用异步加载的方式去获取引用的<code>js</code>，待加载完成后采取执行对应程序，从而避免了等待和浏览器假死的状况。它的语法和应用如下：</p>
<pre><code>// 语法
define(id?,dependencies?,factory); 
// id 即对这个模块命名
// dependencies 这个模块所依赖的其他模块 多个时用数组传递
// factory 加载完成后执行的回调函数

// math.js文件 定义模块
define(function(){
  var obj=xxx;
  // doing somethig 
  return obj
})

// main.js文件 加载模块
define(method,[&apos;math&apos;],function(math){
  //把加载的模块传递进来 doing something
})
</code></pre><p><code>CMD</code>：CMD（Common Module Definition）是<code>Sea JS</code>推广过程中产生的。在 <code>CMD</code> 规范中，一个模块就是一个文件。其语法与<code>comment js</code>类似，不过多了一个外包装；且相对与<code>AMD</code>的提前设置依赖，<code>CMD</code>的区别就是它将依赖内置了，需要时就使用<code>require</code>去获取，从表面上看实现了<code>comment js的浏览器端化</code>，但实质是通过设置外包装 <code>define(function(require, exports, module){}</code>来包裹代码，提前去加载引用的模块，等加载完成后再同步执行。</p>
<pre><code>// 语法 一个模块就是一个文件
define(factory);

//math.js 定义
define(function(require, exports, module){
  exports.obj=xxx;
})
// main.js 加载引用
define(function(require, exports, module){
  var method=require(&apos;math&apos;).obj;
  //doing something
})
// 当然这个模块也可以继续exports接口 让其他模块调用
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/21/模块化：常见规范/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Javascript的继承特性" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/19/Javascript的继承特性/">javascript的继承特性</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
</div>
        <time datetime="2016-05-19T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-19
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="继承有什么作用"><a href="#继承有什么作用" class="headerlink" title="继承有什么作用?"></a>继承有什么作用?</h4><ul>
<li>创造新对象的时候无需重复写一些共有的属性，new的时候会继承给新对象。</li>
<li>继承后，共有的属性和方法是共用的，避免浪费大量的资源。</li>
<li>也方便对一些具有相同特性的对象进行统一修改。</li>
</ul>
<h4 id="常见的创建对象的方式主要有以下几种"><a href="#常见的创建对象的方式主要有以下几种" class="headerlink" title="常见的创建对象的方式主要有以下几种"></a>常见的创建对象的方式主要有以下几种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 方法1 用直接定义object的方法</span><br><span class="line">var obj1=&#123;</span><br><span class="line">  name:&apos;keliangyong&apos;,</span><br><span class="line">  age:25</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 方法2 用函数创造的方法 参数传递进去 把obj return出来</span><br><span class="line">function creatObj(name,age)&#123;</span><br><span class="line">  var obj=&#123;</span><br><span class="line">    name:name,</span><br><span class="line">    age:age</span><br><span class="line">  &#125;;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">var obj2=creatObj(&apos;keliangyong&apos;,25);</span><br><span class="line"></span><br><span class="line">// 方法3 用构造函数的方法new一个对象</span><br><span class="line">function CreatObj(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">var obj3 = new CreatObj(&apos;keliangyong&apos;,25);</span><br></pre></td></tr></table></figure>
<h4 id="Object-create-在继承中的使用"><a href="#Object-create-在继承中的使用" class="headerlink" title="Object.create 在继承中的使用"></a>Object.create 在继承中的使用</h4><p><code>Obj.create(复制目标[,额外属性/值])</code>，创建一个拥有指定原型和若干指定属性的对象。<br>当我有一个构造函数Person，现在想在Person的基础上做一个新的构造函数Student，Person有的我想让Student也有，同时我自己再去给Student加新的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 初始定义</span><br><span class="line">function Person(name, sex)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.printName=function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Student(name, sex, grade)&#123;</span><br><span class="line">  Person.call(this, name, sex);</span><br><span class="line">  this.grade=grade;</span><br><span class="line">&#125;</span><br><span class="line">// 方法一 new创建法</span><br><span class="line">Student.prototype = new Person;  //这样Student的原型中就有Person的所有东西了 但是有很多奇怪的东子也放进去了；比如多了name：undefind，sex：undefined 强迫症表示很难受 想要个干干净净的原型</span><br><span class="line">var s1 = new Student(&apos;小柯&apos;, &apos;男&apos;, &apos;大四&apos;);</span><br><span class="line">// 方法二 Object.creat创建法</span><br><span class="line">Student.prototype = Object.create(Person.prototype); // OK 完成 完美 </span><br><span class="line">var s1 = new Student(&apos;小柯&apos;, &apos;男&apos;, &apos;大四&apos;);</span><br></pre></td></tr></table></figure></p>
<h4 id="hasOwnProperty简介"><a href="#hasOwnProperty简介" class="headerlink" title="hasOwnProperty简介"></a>hasOwnProperty简介</h4><p>hasOwnProperty可以用来判断一个属性是不是这个对象自身所有的，格式<code>obj.hasOwnProperty(prop)</code>,如果是自身所有就会返回<code>true</code>，若不是自身所有而是继承来的话就会返回<code>false</code>.</p>
<h4 id="Object-create的-polyfill的实现"><a href="#Object-create的-polyfill的实现" class="headerlink" title="Object.create的 polyfill的实现"></a>Object.create的 polyfill的实现</h4><pre><code>// 以下是参考了MDN中关于Onject.create的Polyfill写法
Object.copy=function(proto){
  if(typeof proto !== &apos;object&apos;){
    throw TypeError(&apos;Object prototype may only be an Object or null&apos;);
  }
  function Example(){};       // 新建一个空构造函数 
  Example.prototype=proto;   // 考虑到作为原型，所以肯定都是引用类型 直接赋值指向
  var obj = new Example();  // 因为最终返回的是原型对象
  Example.prototype=null;
  if(arguments.length&gt;1){    // 如果参数大于1 说明有附加属性需加入
    for(var prop in arguments[1]){
      if(proto.hasOwnProperty(prop)){   // Object.create要求此处仅自身拥有的可枚举属性才有效
        obj[prop]=arguments[1][prop];   // 所以就用hasOwnProperty来判断。
      }
    }
  }
  return obj;
}
</code></pre><h4 id="通过call去实现已有构造函数特性的复制"><a href="#通过call去实现已有构造函数特性的复制" class="headerlink" title="通过call去实现已有构造函数特性的复制"></a>通过call去实现已有构造函数特性的复制</h4><pre><code>function Person(name, sex){
    this.name = name;
    this.sex = sex;
}
function Male(name, sex, age){
    Person.call(this, name, sex);   //把当前环境作为Person函数的this去执行 在new Male时新对象就成了Person中的this指向
    this.age = age;
}
</code></pre><h4 id="已有一个构造函数，用继承特性在此基础上创造一个新的构造函数"><a href="#已有一个构造函数，用继承特性在此基础上创造一个新的构造函数" class="headerlink" title="已有一个构造函数，用继承特性在此基础上创造一个新的构造函数"></a>已有一个构造函数，用继承特性在此基础上创造一个新的构造函数</h4><pre><code>//补全代码，实现继承 （难度:****）
function Person(name, sex){
  this.name=name;
  this.sex=sex;
}

Person.prototype.getName = function(){
  return this.name;
};    

function Male(name, sex, age){
 Person.call(this,name,age);
 this.age=age;
}

Male.prototype=Object.create(Person.prototype);

Male.prototype.printName = function(){
  console.log(this.getName());
};

Male.prototype.getAge = function(){
  return this.age;
};

var ruoyu = new Male(&apos;若愚&apos;, &apos;男&apos;, 27);
ruoyu.printName();
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/19/Javascript的继承特性/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-对象、原型" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/18/对象、原型/">对象、原型</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
</div>
        <time datetime="2016-05-18T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-18
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="OOP-及其特性"><a href="#OOP-及其特性" class="headerlink" title="OOP 及其特性"></a>OOP 及其特性</h4><p><code>OOP</code>：全称 Object Oriented Programming，面向对象程序设计。传统的计算机程序是由一系列的指令和函数组成，而面向对象编程的程序是由一个个独立的代码块也就是对象组成的，一个个对象分工合作完成任务。<br><code>特性</code>：</p>
<ul>
<li><code>继承性</code>：由构造函数所创建的对象会继承其创造者的一部分公共属性。</li>
<li><code>多态性</code>：由继承而产生相关的不同实例会有不同的具体功能。</li>
<li><code>封装性</code>：在一个对象的内部，某些代码是私有的不能被外界访问到的。</li>
</ul>
<h4 id="如何通过构造函数的方式创建一个拥有属性和方法的对象"><a href="#如何通过构造函数的方式创建一个拥有属性和方法的对象" class="headerlink" title="如何通过构造函数的方式创建一个拥有属性和方法的对象"></a>如何通过构造函数的方式创建一个拥有属性和方法的对象</h4><p>先定义一个函数，里面用<code>this.xx</code>等设置相关值和函数，就是属性和方法啦，然后用<code>new</code>关键字创建一个对象就可以了；例如：</p>
<pre><code>function People(name,age){
  this.name=name;
  this.age=age;
  this.introduce=function(){
    console.log(&apos;Hello , My name is &apos;+this.name+&apos; I am &apos;+age+&apos; years old&apos;);
  }
}
var jon = new People(&apos;jon&apos;,20);
</code></pre><h4 id="prototype-及其特性"><a href="#prototype-及其特性" class="headerlink" title="prototype 及其特性"></a>prototype 及其特性</h4><p><code>prototype</code>：是原型的意思，在javascript中每个对象都有原型也就是prototype属性。这个属性存的是一个地址，指向一个原型对象。可以用这个属性来给对象添加固有属性。<br><code>特征</code>：在原型中所拥有的特性，继承的对象都会有，因为继承的对象都会有一个<strong>proto</strong>属性指向原型。</p>
<h4 id="画出如下代码的原型图"><a href="#画出如下代码的原型图" class="headerlink" title="画出如下代码的原型图"></a>画出如下代码的原型图</h4><pre><code>function People (name){
  this.name = name;
  this.sayName = function(){
    console.log(&apos;my name is:&apos; + this.name);
  }
}

People.prototype.walk = function(){
  console.log(this.name + &apos; is walking&apos;);  
}

var p1 = new People(&apos;饥人谷&apos;);
var p2 = new People(&apos;前端&apos;);
</code></pre><p><img src="http://7xupes.com1.z0.glb.clouddn.com/imgprototype.png" alt="原型图"> </p>
<h4 id="变量name"><a href="#变量name" class="headerlink" title="变量name"></a>变量name</h4><pre><code>function People (){
  var name = &quot;饥人谷&quot;   // 这个name 是函数内的 局部变量
  this.name = &quot;我&quot;;      // 这个name 根据this指向不同而不同 正常运行时是window全局变量；new一个新对象时又是指代新对象的name属性
}
People.name = &quot;jscode&quot;;  // 这个name 是People这个函数的一个属性 函数也是对象

People.prototype.name = &quot;学前端&quot;;  // 这个name是People的原型的一个属性 这样做以后 用People构造的对象就都会继承name这个属性了，但是如果复写的话就会被覆盖。
</code></pre><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="1-创建一个-Car-对象，拥有属性name、color、status；拥有方法run，stop，getStatus"><a href="#1-创建一个-Car-对象，拥有属性name、color、status；拥有方法run，stop，getStatus" class="headerlink" title="1.创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus"></a><strong>1.创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus</strong></h4><pre><code>function Car(name,color,status){
  this.name=name;
  this.color=color;
  this.status=status;
  this.run=function(){
    this.status=&apos;run&apos;;
  }
  this.stop=function(){
    this.status=&apos;stop&apos;;
  }
  this.getStatus=function(){
    return this.status;
  }
}
var car = new Car(&apos;byd&apos;,&apos;white&apos;,&apos;stop&apos;); 
</code></pre><h4 id="2-创建一个-GoTop-对象，当-new-一个-GotTop-对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部；拥有以下属性和方法"><a href="#2-创建一个-GoTop-对象，当-new-一个-GotTop-对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部；拥有以下属性和方法" class="headerlink" title="2.创建一个 GoTop 对象，当 new 一个 GotTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部；拥有以下属性和方法"></a><strong>2.创建一个 GoTop 对象，当 new 一个 GotTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部；拥有以下属性和方法</strong></h4><ul>
<li>ct属性，GoTop 对应的 DOM 元素的容器</li>
<li>target属性， GoTop 对应的 DOM 元素</li>
<li>bindEvent 方法， 用于绑定事件</li>
<li>createNode 方法， 用于在容器内创建节点</li>
</ul>
<pre><code>&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  function GoTop($ct){
    this.ct=$ct;
    this.target=$(&apos;&lt;button&gt;点我回到顶部&lt;/button&gt;&apos;);
    this.creatNode=function(){
      this.ct.append(this.target);
    }
    this.bindEvent=function(){
      this.target.on(&apos;click&apos;,function(){
        $(window).scrollTop(0);
      })
    }
    this.creatNode();
    this.bindEvent();
  }
  var goTop = new GoTop($(&apos;body&apos;));
&lt;/script&gt;
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/18/对象、原型/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Http" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/16/Http/">Http</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Http/">Http</a></li></ul>
</div>
        <time datetime="2016-05-16T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-16
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h4><p>OSI：Open System Interconnection Refer Model 开放式系统互联通信参考模型，是由国际标准化组织提出的一种概念模型，是一个试图让各种计算机在全世界范围内连成网络的标准框架；它将网络通信分成七个层面。从距离用户最近至最底层简述如下：</p>
<ul>
<li><code>应用层 Application</code>：用户交互的对象，用户通过这一层进行信息交互。通俗点例如chrome浏览器、或者发邮件的outlook就是这一层。</li>
<li><code>表示层 Presentation</code>：这一层是操作系统所在的层，处理数据，转化加密等确保另一个系统能识别你的数据。</li>
<li><code>会话层 Session</code>：负责你的电脑与服务器的通信连接与维护，创建连接→请求→响应。</li>
<li><code>传输层 Transport</code>：把传输表头加至数据以形成数据包，控制调节数据的传输，决定类似一次发送多少数据的问题。</li>
<li><code>网络层 Network</code>：路由的工作层，它决定路径的选择和转寄。</li>
<li><code>数据链路层 Data Link</code>：交换机的工作层，负责网络寻址、错误侦测和改错。</li>
<li><code>物理层 Physical</code>：最底层的物理联网介质和数据传输实现，网线、连接器及比特流的传输等。</li>
</ul>
<h4 id="HTTP-的工作原理"><a href="#HTTP-的工作原理" class="headerlink" title="HTTP 的工作原理"></a>HTTP 的工作原理</h4><p><code>HTTP</code> 全称 <code>Hyper Text Transfer Protocol</code> 即超文本传输协议；它是一个客户端终端和服务器端请求和应答的标准。它的请求和响应步骤如下：</p>
<ul>
<li><code>建立连接</code>：客户端与服务器端建立一个TCP连接。</li>
<li><code>发起请求</code>：客户端向服务器端发起Http请求，会发送请求报文，由请求行、消息报头和请求正文组成。</li>
<li><code>返回响应</code>：服务器端接收到请求并进行解析，定位请求资源，给客户端发送响应报文，由状态行、消息报头和响应正文组成。</li>
<li><code>释放TCP连接</code>：服务器关闭TCP连接。（如果连接模式是keepalive的话会保持一段时间可继续接受请求）</li>
</ul>
<h4 id="URI-的格式及常见的协议"><a href="#URI-的格式及常见的协议" class="headerlink" title="URI 的格式及常见的协议"></a>URI 的格式及常见的协议</h4><p><code>URI</code> 全称<code>Uniform Resource Identifier</code> 统一资源标志符，是一个用于标识一个互联网资源名称的字符串。由两个子集构成，通过描述资源位置确定资源的URL，以及通过名字来识别确定资源的URN。它的格式如下：<br> <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;hash&gt;</code><br><code>http://</code> <code>user:pass</code>@<code>www.example.com</code> <code>:80</code> <code>/dir/index</code> <code>?uid=1&amp;nam=2</code> <code>#ch1</code></p>
<ul>
<li><code>&lt;scheme&gt;</code> <code>协议方案名</code> 常见的有http、https等。</li>
<li><code>&lt;user&gt;:&lt;password&gt;</code> <code>用户的登录信息</code> 现在一般不会把登录信息放在url中。</li>
<li><code>&lt;host&gt;</code> <code>服务器地址</code> 用户一般使用域名方便记忆，浏览器经DNS解析去访问对应IP地址。</li>
<li><code>&lt;port&gt;</code> <code>端口号</code> 服务器的进程接口，80是http协议默认的端口号，ftp协议默认21端口，https默认443端口。</li>
<li><code>&lt;port&gt;</code> <code>路径</code> 找到服务器后再去对应的路径下寻找资源。</li>
<li><code>&lt;params&gt;</code> 在一些协议中需要参数来访问资源，参数用名值对用<code>；</code>隔开。</li>
<li><code>&lt;query&gt;</code> 查询字符串，常见的是get请求中data以此形式传给服务器。</li>
<li><code>&lt;hash&gt;</code> 片段标识符-哈希，之前作为页面锚点的时候见过。</li>
</ul>
<p>常见的协议有 Http、Https、FTP、SSH等。</p>
<h4 id="HTTP-协议几种和服务器交互的方法"><a href="#HTTP-协议几种和服务器交互的方法" class="headerlink" title="HTTP 协议几种和服务器交互的方法"></a>HTTP 协议几种和服务器交互的方法</h4><ul>
<li><code>GET</code>：得到，最常用的方法，向服务器发送请求要求获取某个资源。</li>
<li><code>HEAD</code>：头，亦即不需要数据主体只想得到描述资源信息的头部，一般用于查看资源信息、查看状态码看下资源是否存在、查看首部看下资源有没有被修改。</li>
<li><code>POST</code>：投递，好理解，就是向服务器发数据，一般是在html表单中用于向服务器提交表单信息的。</li>
<li><code>PUT</code>：放，就是向服务器写入资源，修改某个内容。</li>
<li><code>TRACE</code>：跟踪，这个方法会在最后发往服务器时，返回一个TRACE响应给客户端，告诉客户端最终服务器收到的请求报文是什么样的。</li>
<li><code>DELETE</code>：删除，要求服务器删掉给定url下的资源，服务器可能不会支持。</li>
<li><code>OPTIONS</code>：其他，用来查询服务器支持哪些功能。</li>
</ul>
<h4 id="状态码200，301，-304，403-404-500，503分别代表什么意思"><a href="#状态码200，301，-304，403-404-500，503分别代表什么意思" class="headerlink" title="状态码200，301， 304，403 , 404 , 500，503分别代表什么意思"></a>状态码200，301， 304，403 , 404 , 500，503分别代表什么意思</h4><ul>
<li><code>200 OK</code> 请求已成功 根据请求方式的不同会有不同的反馈内容</li>
<li><code>301 Moved Permanently</code>  所请求的资源被永久性地移动到另一个地方 响应会返回新的url 下次客户端会按照新的url去访问</li>
<li><code>304 Not Modified</code> 客户端有缓存的文档 当再一次发起请求时 服务器经比对后发现文档内容并没有变化时就会返回此状态码 让客户端使用本地缓存 </li>
<li><code>403 Forbidden</code> 服务器已经理解请求 但拒绝执行 一般是因为没有对应的权限</li>
<li><code>404 Not Found</code> 请求失败 在服务器上找不到你所请求的资源</li>
<li><code>500 Internal Server Error</code>服务器出错了 无法完成客户端的请求</li>
<li><code>503 Service Unavailable</code>服务器过载了 目前无法处理客户端的请求</li>
</ul>
<h4 id="报文由哪几部分组成"><a href="#报文由哪几部分组成" class="headerlink" title="报文由哪几部分组成"></a>报文由哪几部分组成</h4><p>http报文有请求报文和响应报文，是一个简单的格式化数据块，它由以下3个部分组成：</p>
<ul>
<li><code>start line</code>：起始行  对报文进行简单描述</li>
<li><code>header</code>：包含一些属性的首部块</li>
<li><code>body</code>：数据的主题部分，有些请求不需要返回这部分</li>
</ul>
<h4 id="请求头的格式和作用"><a href="#请求头的格式和作用" class="headerlink" title="请求头的格式和作用"></a>请求头的格式和作用</h4><p><code>作用</code>：为请求添加额外的信息，来告诉服务器客户端的信息和能力，服务器可以据此为客户端提供更好的响应。<br><code>格式</code>：是名/值的形式；名字后面跟着冒号，加上可选的空格，再加上字段值，最后回车或换行。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgrequestHead.png" alt="0_1463029655966_upload-264bf520-20fb-459c-986e-9cbf5da71be7"><br><code>范例</code>：</p>
<ul>
<li><code>GET/HTTP/1.1</code> 请求方法、协议、版本号 ←这是请求报文起始行 </li>
<li><code>Host</code>：服务器地址</li>
<li><code>Connection</code>：连接方式 一般请求后就断开 图中是keep-alive，可以继续接收请求。</li>
<li><code>Accept</code>：说明我这个客户端可以接受哪些类型的资源。</li>
<li><code>Upgrade-Insecure-Requests</code>：自动升级请求，在https承载的页面上不允许出现http请求，出现就会报警，这个属性会自动替换https请求。</li>
<li><code>User-RefererAgent</code>：用户代理也就是浏览器客户端自身的信息。</li>
<li><code>Referer</code>：客户端是从哪里跳转过来的。例如我们从百度跳到饥人谷官网，这里就会是百度的网址。</li>
<li><code>Access-Encoding</code>：客户端可以接受的编码类型。</li>
<li><code>Accept-Language</code>：客户端可以解析接受的语言。</li>
<li><code>Cookie</code>：服务器端为了辨识用户身份而留在客户端的数据，发送请求时客户端会把<code>cookie</code>一起发送给服务器。</li>
</ul>
<h4 id="首部的格式和作用"><a href="#首部的格式和作用" class="headerlink" title="首部的格式和作用"></a>首部的格式和作用</h4><p><code>作用</code>：HTTP的首部向请求或响应报文添加了一些附加信息，它是一些名/值对的列表。它分为通用首部、请求首部、响应首部、实体首部和拓展首部。<br><code>格式</code>：名字后面跟着冒号，加上可选的空格，再加上字段值，最后回车或换行。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imghead.png" alt="0_1463034116314_upload-858a3ce0-998c-4ae7-ad2f-44aab51e1cff"><br><code>范例</code>：</p>
<ul>
<li><code>HTTP/1.1 200 OK</code> 协议/版本 状态码 释义  ←这是响应报文起始行 不属于首部</li>
<li><code>Server</code>：属于响应信息性首部，服务器用的是哪一种及版本 图中用的是nginx 版本1.6.2 </li>
<li><code>Data</code>：属于通用信息性首部，提供日期和事件说明报文是什么时候创建的。</li>
<li><code>Content-Type</code>：属于实体内容首部，告诉客户端主体的数据类型。</li>
<li><code>Transfer-Encoding</code>：属于通用信息性首部，传输的编码方式，图中chunked是分块传输例如小说分一章一章传输。</li>
<li><code>Connection</code>：属于通用信息性首部，可以指定请求/响应的连接选项，图中keep-alive在响应后连接依然可以存在一段时间。</li>
<li><code>X-Powered-By</code>：显示此资源用什么技术开发及对应版本 感觉只有PHP</li>
<li><code>Expires</code>：属于实体缓存首部，提示缓存过期的时间，超过这个时间就需要重新获取资源。</li>
<li><code>Pragma</code>：属于通用缓存首部，另一种随报文传送的指示，并不专用于缓存。</li>
<li><code>Cache-Control</code>：属于通用缓存首部，随报文传送缓存指示，图中private是指私人缓存每个人不一样。</li>
<li><code>Content-Encoding</code>：属于实体内容首部，告诉客户端对主体执行的编码方式。</li>
<li><code>Vary</code>：属于响应协商首部，是一个首部列表，服务器会根据这些首部的内容挑出最适合的资源版本发给客户端。</li>
</ul>
<h4 id="主体的作用"><a href="#主体的作用" class="headerlink" title="主体的作用"></a>主体的作用</h4><ul>
<li>实体的主体部分就是HTTP要传输的内容了，一般是图片、视频、HTML文档等。下面饥人谷首页的响应实体，也就是HTML文档了。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgbody.png" alt="0_1463037793472_upload-3892ad8a-24a1-4d3a-9bf2-23649fda8de5"></li>
</ul>
<h4 id="浏览器缓存是如何控制"><a href="#浏览器缓存是如何控制" class="headerlink" title="浏览器缓存是如何控制"></a>浏览器缓存是如何控制</h4><ul>
<li><code>是什么</code>：浏览器缓存是web缓存中的一个类型，与公用缓存不同，浏览器一般都有内建的私有缓存，会缓存已经访问过的页面，也就是把资源复制了一份放在本地，缓存可以减少网络带宽的压力、降低服务器的压力、也能让我们更快地打开页面获得资源。</li>
<li><code>缓存页面、过期时间</code>：在我们首次请求资源或页面时，原始服务器利用<code>HTTP</code>的<code>cache-control首部</code>或<code>expires首部</code>给文档加上了过期时间，标明了保质期。在保质期内请求已缓存的资源时，浏览器就不会向服务器发送请求而是直接使用本地缓存。</li>
<li><code>过期后的再验证</code>：当过了保质期以后呢，这个时候浏览器就会向服务器发起请求同时附带过期时间。若文档与缓存的副本不一样服务器就响应新的文档给浏览器，同时浏览器会继续缓存新的文档；若服务器比对后发现文档没有变化，就会发个新的过期时间让浏览器继续使用本地缓存。<code>对缓存再验证最有用的两个首部是If-Modified-Since和If-None-Match</code>。最后引用博客园的一张图面解释，更加清晰。<ul>
<li><code>If-Modified-Since</code>：当资源过期时，再请求时若发现资源带有<code>Last-Modified</code>（最后修改日期）声明时，会带上<code>If-Modified-Since：Last-Modified Data</code>发给服务器，收到后服务器就会比对最后修改时间，若没被修改就返回<code>304 Not Modified</code>响应报文并且附带新的过期事件；若被修改了就返回新的文档和过期时间。</li>
<li>If-None-Match：如果在资源过期后再请求时发现资源带有Etage声明（资源在服务器的唯一标识，生成规则服务器自定），会带上<code>If-None-Match：Etage值</code>发给服务器，收到后服务器就会进行比对校验来决定返回200还是304，响应与If-Modified-Since相同。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imground.png" alt="0_1463123874986_201211281402442505 (1).png"> </li>
</ul>
</li>
</ul>
<h4 id="下图各个参数是什么意思"><a href="#下图各个参数是什么意思" class="headerlink" title="下图各个参数是什么意思"></a>下图各个参数是什么意思</h4><p><img src="http://7xupes.com1.z0.glb.clouddn.com/imground1.png" alt=""><br><code>General：概述</code></p>
<ul>
<li><code>Request URL</code>：请求的资源的URL也就是位置</li>
<li><code>Request Method</code>：客户端向服务端发出请求的方法，图中是用PUT方法</li>
<li><code>Status Code</code>：状态码，图中是200 表示成功OK</li>
<li><code>Remote Address</code>：资源所在的IP地址</li>
</ul>
<p><code>Response Headers 响应头</code></p>
<ul>
<li><code>Connection</code>：连接方式；图中是keep-alive，在请求后的一段时间内还是相连的，可直接继续发送请求。</li>
<li><code>Content-Length</code>：主体的长度或尺寸</li>
<li><code>Content-type</code>：主体的类型</li>
<li><code>Date</code>：报文创建的时间</li>
<li><code>Server</code>：服务端软件及版本，图中是Nginx/1.6.2</li>
<li><code>X-Powered-By</code>：开发资源的技术是Express</li>
</ul>
<p><code>Request Headers 请求头</code></p>
<ul>
<li><code>Accept</code>：我这个客户端可以接受哪些类型的资源</li>
<li><code>Accept-Encoding</code>：客户端可以接受的编码类型</li>
<li><code>Accept-Language</code>：客户端可以解析接受的语言</li>
<li><code>Cookie</code>：服务器端为了辨识用户身份而留在客户端的数据，发送请求时客户端会把<code>cookie</code>一起发送给服务器。</li>
<li><code>Host</code>：服务器地址</li>
<li><code>Origin</code>：所请求的资源的源</li>
<li><code>Referer</code>：客户端是从哪里跳转过来的。例如我们从百度跳到饥人谷官网，这里就会是百度的网址</li>
<li><code>User-Agent</code>：用户代理也就是浏览器客户端自身的信息</li>
<li><code>X-Requested-With</code>：请求的方式，这里是AJAX</li>
</ul>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/16/Http/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-this、闭包" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/14/this、闭包/">This、闭包</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
</div>
        <time datetime="2016-05-14T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-14
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="apply、call-的作用及区别"><a href="#apply、call-的作用及区别" class="headerlink" title="apply、call 的作用及区别"></a>apply、call 的作用及区别</h4><ul>
<li>作用：在指定<code>this</code>值和<code>参数</code>值的前提下去调用函数或方法。</li>
<li>区别：<code>A for array,C for comma !</code>  apply方法接受的是一个包含多个参数的数组，而call方法接受的是一个参数列表。<ul>
<li><code>theFunction.call( this, arg1, arg2, arg3... )</code></li>
<li><code>theFunction.apply( this, [arg1,arg2,arg3...] )</code></li>
</ul>
</li>
</ul>
<h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="1-以下代码输出什么"><a href="#1-以下代码输出什么" class="headerlink" title="1.以下代码输出什么?"></a><strong>1.以下代码输出什么?</strong></h4><pre><code>var john = { 
  firstName: &quot;John&quot; 
}
function func() { 
  alert(this.firstName + &quot;: hi!&quot;)
}
john.sayHi = func   // 把 func 拷贝了一份，存在对象john的sayHi属性中
john.sayHi()    // 输出 &quot;john: hi!&quot;  这个函数的拥有者是john这个对象 this指向john
</code></pre><h4 id="2-下面代码输出什么，为什么"><a href="#2-下面代码输出什么，为什么" class="headerlink" title="2.下面代码输出什么，为什么"></a><strong>2.下面代码输出什么，为什么</strong></h4><pre><code>func()         // 输出 window对象 这个函数的拥有者是window对象或称全局对象

function func() { 
  alert(this)        
}
</code></pre><h4 id="3-下面代码输出什么"><a href="#3-下面代码输出什么" class="headerlink" title="3.下面代码输出什么"></a><strong>3.下面代码输出什么</strong></h4><pre><code>function fn0(){
  function fn(){
    console.log(this);
  }
  fn();
}

fn0();  // 输出window对象 fn0这个函数的拥有者是window对象 其内部的this指向window对象


document.addEventListener(&apos;click&apos;, function(e){
  console.log(this);     // 点击 输出document对象 实质是拷贝了一份函数给document的click属性 这个函数属于document对象
  setTimeout(function(){
    console.log(this);   // 200毫秒后 输出window对象 setTimeout是运行在全局环境下的 属于window对象
  }, 200);
}, false);
</code></pre><h4 id="4-下面代码输出什么，why"><a href="#4-下面代码输出什么，why" class="headerlink" title="4.下面代码输出什么，why"></a><strong>4.下面代码输出什么，why</strong></h4><pre><code>var john = { 
  firstName: &quot;John&quot; 
}

function func() { 
  alert( this.firstName )
}
func.call(john)  // 输出 &quot;John&quot; call在指定了john作为this的前提下去调用了func
</code></pre><h4 id="5-代码输出？"><a href="#5-代码输出？" class="headerlink" title="5.代码输出？"></a><strong>5.代码输出？</strong></h4><pre><code>var john = { 
  firstName: &quot;John&quot;,
  surname: &quot;Smith&quot;
}

function func(a, b ) { 
  alert( this[a] + &apos; &apos; + this[b] )
}
func.call(john, &apos;firstName&apos;, &apos;surname&apos;)  // 输出 &quot;John Smith&quot; call在指定john作为this的前提下调用了func
</code></pre><h4 id="6-以下代码有什么问题，如何修改"><a href="#6-以下代码有什么问题，如何修改" class="headerlink" title="6.以下代码有什么问题，如何修改"></a><strong>6.以下代码有什么问题，如何修改</strong></h4><pre><code>var module= {
  bind: function(){
    $btn.on(&apos;click&apos;, function(){
      console.log(this) //this指的是btn这个元素 实质拷了一份函数给btn的click属性 函数属于btn
      this.showMsg();  // 报错 这不是一个函数
    })
  },

  showMsg: function(){
    console.log(&apos;饥人谷&apos;);
  }
}

var module= {
  bind: function(){
    var self=this;
    $btn.on(&apos;click&apos;, function(){
      console.log(this) 
      self.showMsg(); // 本来我是直接改成module的 看了老师对育薇同学的点评   发现以后改名的话会出问题 其他人不容易发现里面这个东西。。维护太艰难 也意识到工程化模块化的重要性了
    })
  },

  showMsg: function(){
    console.log(&apos;饥人谷&apos;);
  }
}
</code></pre><h4 id="7-下面代码输出什么-why"><a href="#7-下面代码输出什么-why" class="headerlink" title="7.下面代码输出什么? why"></a><strong>7.下面代码输出什么? why</strong></h4><pre><code>obj = {
  go: function() { alert(this) }
}

obj.go();    // 输出 obj对象 这个函数属于obj

(obj.go)();     // 输出 obj对象 全局中并没有这个函数 函数还是在obj中是属于obj的

(a = obj.go)();     // 输出 window对象 函数被赋值给了全局变量a再遇到括号执行了 这个函数属于window对象

(0 || obj.go)();     // 输出 obj对象 看了同学们的解释才知道 多了一个传递的过程 以一个全局变量做中转来存储结果 所以与上一例相同
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/14/this、闭包/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-同源策略、跨域" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/12/同源策略、跨域/">同源策略、跨域</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Http/">Http</a></li></ul>
</div>
        <time datetime="2016-05-12T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-12
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h4><ul>
<li><code>协议名+域名+端口</code>就是源，三者都相同视为同源。</li>
<li>不同源的客户端脚本在没有明确授权下，不能读写对方的资源（可引用js、css、png）。例：a.com域名下的js无法操作b.com域名下的对象。</li>
</ul>
<h4 id="什么是跨域？跨域的几种实现形式"><a href="#什么是跨域？跨域的几种实现形式" class="headerlink" title="什么是跨域？跨域的几种实现形式"></a>什么是跨域？跨域的几种实现形式</h4><ul>
<li>同源策略在保证web安全的同时，也降低了网站交互的灵活性；有些大网站因为文件多数据大所以文件可能放在不同的服务器上，那么就有了突破同源策略的限制，以达到交互数据的目的。<strong>跨域就是指当域名不同时，我能够突破同源策略的限制去交互数据</strong>。（协议和端口不同的话在前台是无法实现的）。</li>
<li>跨域有以下几种实现形式：<ul>
<li><strong>降域</strong>：对于有相同的后缀（就是域名开头不一样但后面是一样的）的两个源，可以使用<code>document.domain=&quot;域名后缀&quot;</code>来改变自己的域名，这样就同源了！(两个源都要设置domain才可)一个域名可以往下降（降为后缀）但不能往上升，但降域后可以回复到原来的域名，测试图如下：<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgdomain.png" alt="0_1462687799119_upload-fdf8da8b-fb59-4033-936c-cfecaf16303d"> </li>
<li><strong>jsonp</strong>：上一题提到不同源虽然不能读写，但可以引用js，关键点在这；我们可以让引用的js附带数据来调用我们预先定义的函数，而数据当作参数传入。例如：a和b两个网站约定好了一个函数名，当<code>a</code>用<code>src</code>引用b的<code>js</code>时，<code>b</code>中的这段<code>js</code>包含这个函数名并且在后面加个括号中间放入数据，从b的角度来看这段js只是<code>数据名（{json数据}）</code>，但是在a看来，你的那个数据名在我这是个函数啊，你还有括号和形参，然后在a中这个函数就被调用执行了，而b中的数据就被当作参数传入这个函数。</li>
<li><strong>CORS：跨域资源共享</strong>这是一个W3C标准，顾名思义它允许浏览器向跨源服务器发起<code>XMLHttpRequest请求</code>，和ajax同源的使用方法一致（区别在于对于跨域请求浏览器的请求会有附加的相关设置，用户看不到），分简单请求和非简单请求。目前所有浏览器都支持（IE需要10及以上才完全支持）CORS，但是需要服务器端有CORS接口，且要有服务器许可的源才可实现跨域资源共享。</li>
<li><strong>[HTML5]postMessage</strong>：在HTML5中，window增加了一个<code>新方法postMessage</code>用于给目标源发送信息，格式如下：<code>windowobj.postMessage(message,targetOrigin)</code>，而目标源会有一个叫<code>message</code>的事件用来监听<code>postMessage</code>，判断是允许的源所发来的数据后，就可以接收做处理。</li>
<li><strong>hash方法</strong>：<code>url→（协议+域名+端口+路径+查询字符串+片段标识符）</code>，其中片段标识符就是<code>hash</code>以<code>#</code>开头；因为同源策略不允许读写但可以引用，那么我在a中引入一个<code>iframe</code>（内联框架-另一个页面）且<code>src</code>指向<code>b.html</code>，此时的<code>src</code>是a页面输入的；然后我在b页面中用<code>location.hash</code>去修改自身<code>hash</code>也就是数据赋给<code>hash</code>，此时我再去<code>a</code>页面读取<code>iframe</code>的属性<code>src</code>，这个<code>src</code>就会被更新带有<code>hash</code>,处理后我就得到了<code>b</code>中的数据了。（此方法要注意<code>a</code>读取<code>src</code>的时机，要不停地去检测是否变化）<br>→→（上面叙述有误，不能直接修改<code>location.hash</code>，被同源禁止，而是要在<code>b</code>中再新建一个指向<code>a.com</code>并且带有<code>b</code>中数据做<code>hash</code>的<code>代理iframe</code>，利用这个<code>代理iframe</code>与<code>a.com</code>同源的特性，再修改<code>父父页面</code>也就是<code>a.com</code>的<code>hash</code>，这样<code>a</code>读取<code>hash</code>就得到了数据，可参考最后一题实践截图，但基本原理是对的，就不改了）</li>
<li><strong>window.name方法</strong>：与<code>hash</code>方法类似，这个方法的核心是利用<code>window.name</code>不随域名改变而变化，只随<code>tab页面</code>的开启关闭而改变的特性。据此特性，我在<code>a页面</code>添加一个<code>iframe</code>，这个<code>iframe</code>指向<code>代理1页面</code>；代理1页面干两件事，把要传给b的数据命名为自己的<code>windowname</code>，修改自身<code>location.href</code>跳转到<code>b</code>；<code>b</code>读取<code>windowname</code>知道了<code>a</code>想要什么，就去数据库查，找到后把数据赋值给<code>windowname</code>，<code>location.href</code>跳转到<code>代理2页面</code>；代理2页面干两件事，读取windowname，用<code>window.parent.函数名</code>调用<code>父window(即a页面)</code>的函数；此时<code>a</code>页面提前定好的函数就<code>doing</code>啦，<code>a</code>啥也不干，就空想数据到来后怎么处理，然后插个<code>iframe</code>告诉<code>代理1</code>自己想要什么就可以坐等数据来了，人生赢家！</li>
</ul>
</li>
</ul>
<h4 id="jsonp-的原理"><a href="#jsonp-的原理" class="headerlink" title="jsonp 的原理"></a>jsonp 的原理</h4><ul>
<li>jsonp的原理：先串通好，你先把数据用括号包起来再加个名字，对就是json格式的数据带名字滴，像<code>data({xxx:&#39;xxx&#39;,xxx:&#39;xxx&#39;})</code>这样，记得文件类型改成js；我利用可跨域引用的特点来引用你的js，定个函数起名就和那个数据名字一样，你那边的带名字的数据的js到了我这，咦你数据名和我函数名一样呢，很明显呐就变成一个赤裸裸的带参数的函数，不好意思我看到函数就执行啦，数据就被当成函数参数啦，一切都是套路。（正经的可以参考上一题的jsonp，因为有点重复就用更加通俗的语言来写一写，印象更深刻）</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul>
<li>Cross Origin Resource sharing 跨域资源共享，为了满足日益增长的跨域交互需求（折腾）W3C推荐了这种机制，它与我们用的ajax同源请求有什么区别么？有，多了一些组件、请求头等相关设置，但基本还是原来的配方，还是XMLHttpRequest这个对象，正常向有许可的网站发起ajax请求即可！现在它合法了只要对方允许你读取就可以。其实当你读取另一个站的资源时，浏览器就已经发起跨站请求了（现在基本新版浏览器都支持CORS，IE就不说了），只不过因为你没得到对方网站的允许（对方页面未声明你可以访问它），所以浏览器拦截了返回结果并只是告诉你，你不能跨域什么的，以上，可参考上一题。</li>
</ul>
<h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="本地搭建服务器，演示同源策略"><a href="#本地搭建服务器，演示同源策略" class="headerlink" title="本地搭建服务器，演示同源策略"></a>本地搭建服务器，演示同源策略</h4><ul>
<li>修改了本地<code>host</code> 让多个网址映射到本地服务器</li>
<li>我在<code>a.11.com</code>下用ajax向<code>11.com</code>发起请求 </li>
<li>浏览器报错：提示XMLHttpRequest加载失败，请求我帮你发出去了，服务器也给我结果了，但是我在服务器的返回结果的头部没有发现‘请求控制允许源’这么一个东西（Tips：如果有那就是CORS啦），所以<code>a.11.com</code>你的访问是不被允许的。那么这就是同源策略，没有对方允许不能读写对方资源！<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgorigin.png" alt="同源策略"> </li>
</ul>
<h4 id="至少使用一种方式解决跨域问题"><a href="#至少使用一种方式解决跨域问题" class="headerlink" title="至少使用一种方式解决跨域问题"></a>至少使用一种方式解决跨域问题</h4><ul>
<li><strong>降域</strong>：我在<code>a.11.com</code>和<code>11.com</code>中都赋值<code>domain=&quot;11.com</code>;注意要两个页面都给<code>domain</code>赋值！！用<code>iframe</code>的方法。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgdowndomain.png" alt="降域"> </li>
<li><strong>jsonp</strong>：把数据用json格式弄好包成js文件放在b.22.com，我在a中引用b中的js，并定义一个同名函数来打印数据。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgjsonp.png" alt="jsonp"> </li>
<li><strong>CORS</strong>：这个简单，我在b.com加个声明，允许a.com来访问我，然后用ajax请求就OK！<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgcors.png" alt="CORS"> </li>
<li><strong>[html5]postMessage</strong>：我在a.com中用<code>iframe.contentWindow.postMessage(&#39;message&#39;,targetOrigin )</code>给b.com发送消息，在b.com中给window绑定监听事件，如果message触发我先判断是不是a发来的，是我就打印，搞定！<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgpostmessage.png" alt="postMessage"> </li>
<li><strong>hash方法</strong>：hash方法的原理是a内嵌iframe指向b，b找到数据并新建一个和a.com同源的iframe而且把数据放在路径hash中，利用新建的iframe与a同源的特性修改父父页面也就是a页面的hash（把自己的hash赋给父父hash），a再去读取自身hash即可。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imghsah.png" alt="hash"><br>a.com下的a.11.htm和代理proxy.htmll如下：</li>
</ul>
<pre><code> &lt;p&gt;我是a.11.com&lt;/p&gt;
 &lt;iframe src=&quot;//b.22.com/test/b.22.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  var data =location.hash.substring(1);
  console.log(data);    
&lt;/script&gt;

&lt;p&gt;我是a.com下的 proxy.html&lt;/p&gt;
&lt;p&gt; 作用是代理&lt;/p&gt;
  &lt;script&gt;
    parent.parent.location.hash=self.location.hash.substring(1);
  &lt;/script&gt;
</code></pre><ul>
<li><strong>window.name方法</strong>：tab页面不随域名跳转改变而改变，我先建一个内联iframe修改window.name跳转去b，b读取就知道我想要什么，然后b去找数据，找到后b把数据赋给window.name，再跳转回来，我读取winwod.name就得到数据。<br><img src="http://7xupes.com1.z0.glb.clouddn.com/imgwindowname.png" alt="window.name方法"> </li>
</ul>
<pre><code>&lt;p&gt;我是a.11.com&lt;/p&gt;
&lt;iframe src=&quot;//b.22.com/test/b.22.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  function print(data){
    console.log(data);
  }
&lt;/script&gt;
&lt;!-- //以下是 b.22.com 下的 b.22.html
&lt;p&gt;我是b.22.com&lt;/p&gt;
&lt;script&gt;
  window.name=&apos;这是来自b.com的数据&apos;;
  location.href=&apos;//a.11.com/test/a.proxy.html&apos;;
&lt;/script&gt; --&gt;

&lt;!--   //以下是 a.11.com 下的 a.proxy.html
&lt;p&gt;我是a.com下的 proxy.html&lt;/p&gt;
&lt;p&gt; 作用是代理&lt;/p&gt;
&lt;script&gt;
  window.parent.print(window.name);
&lt;/script&gt; --&gt;
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/12/同源策略、跨域/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Jquery常用方法" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/10/Jquery常用方法/">Jquery 常用方法</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jquery/">Jquery</a></li></ul>
</div>
        <time datetime="2016-05-10T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-10
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="Jquery-中，-document-ready-和window-onload-的区别"><a href="#Jquery-中，-document-ready-和window-onload-的区别" class="headerlink" title="Jquery 中， $(document).ready()和window.onload 的区别"></a>Jquery 中， <code>$(document).ready()</code>和<code>window.onload</code> 的区别</h4><ul>
<li><code>$(document).ready()</code>是指当DOM加载完成可以被javascript去操作时就会执行ready括号中的函数。</li>
<li>和<code>window.onload</code> 的区别如下：<br>  1.<code>$(document).ready()</code>是jquery中的方法，等DOM树就绪后就会执行；<code>window.onload</code>是原生js中的一个对象，不仅要等DOM树就绪还要图像、内部框架等，页面整个加载完呈现出来才会执行。<br> 2.<code>$(document).ready()</code>像事件绑定的原理，可以设置多次，DOM加载完就执行所有预先设置的函数；<code>window.onload</code>因为是类似给window对象的onload属性赋值所以只能执行一个，后设置的将覆盖前面的。<br> 3.<code>$(document).ready()</code>可以简写成<code>$(func)</code>；<code>window.onload</code>没有简写。</li>
<li>其他写法：<code>$(document).ready()</code>可以简写成<code>$(func)</code>；替代方法的话没有，但是需要注意jquery中的另外一个<code>$(window).load( )</code>它会等图像、内部框架等，页面整个加载呈现完才执行而不仅仅是DOM。</li>
</ul>
<h4 id="node-html-和-node-text-的区别"><a href="#node-html-和-node-text-的区别" class="headerlink" title="$node.html() 和 $node.text() 的区别"></a>$node.html() 和 $node.text() 的区别</h4><ul>
<li>和原生Js类似；<code>$node.html()</code>是获取或设置node节点的html内容，输出时包含标签代码写入时标签代码也会正常生效；</li>
<li><code>$node.text()</code>是获取或设置node节点的文本内容，输出时是把内部所有文本做一个拼接后输出，输入时把节点内部整个清空放入输入值（注意标签代码会被转义为文本）。</li>
</ul>
<h4 id="extend-的作用和用法"><a href="#extend-的作用和用法" class="headerlink" title="$.extend 的作用和用法"></a>$.extend 的作用和用法</h4><ul>
<li><code>$.extend</code>的作用是将多个对象的值（与目标对象比较，把目标对象所没有的值添加到目标对象中）合并到目标对象中。</li>
<li>用法：<code>$.extend(true,target,obj1[,objn])</code>，若不需要深拷贝请将第一个参数true去掉（注意不支持false！）。<br>注意数组或对象浅拷贝时target的值可能会被覆盖而不是添加，此时最好用深拷贝！<br>目标对象可以是一个空对象（例如想合并两个对象，把其中一个作为目标对象的话会被修改，我既想得到合并后的对象，也想保留这两个对象，这时可以用一个空对象去做target） </li>
</ul>
<h4 id="JQuery-的链式调用"><a href="#JQuery-的链式调用" class="headerlink" title="JQuery 的链式调用"></a>JQuery 的链式调用</h4><ul>
<li>链式调用：在jquery中，它的很多方法调用后的返回值依然是jequery对象，那么对于像对DOM进行操作的任务中我们就无需先取得元素赋值给新建变量，再针对这个新建变量进行操作；例如<code>$(&#39;#head&#39;)</code>它是一个表达式，和被选中的id为head的这个元素是等价的，<code>$(&#39;#head&#39;).find(&#39;.box&#39;)</code>就表示先选中id为head的元素再在head元素下寻找class为box的元素，当然后面还可以接着给它绑定事件。</li>
<li>链式调用非常方便，真的是<code>write less do more！</code>，而且思路也很清晰，让代码看起来更简洁易懂。</li>
</ul>
<h4 id="JQuery-ajax-中缓存怎样控制"><a href="#JQuery-ajax-中缓存怎样控制" class="headerlink" title="JQuery ajax 中缓存怎样控制"></a>JQuery ajax 中缓存怎样控制</h4><ul>
<li>一般来说浏览器会将每次请求的内容缓存起来，这样的话下次是同样的请求就直接在本地调用无需再发请求，但有时候如果是版本更新或者不想让浏览器使用缓存时怎么办呢？</li>
<li>在<code>jquery.ajax(opts)</code>中有一个参数是cache，我们把它设为false即可让浏览器不读取本地缓存，其原理是类似在请求中加时间戳，这样浏览器以为两次请求是不同的而不会去调用缓存，但时间戳并不影响数据的获取，我们得到的依然是我们想要的。</li>
</ul>
<h4 id="jquery-中-data-函数的作用"><a href="#jquery-中-data-函数的作用" class="headerlink" title="jquery 中 data 函数的作用"></a>jquery 中 data 函数的作用</h4><ul>
<li>在jquery中data函数允许我们把一些数据绑定到DOM元素上，避免循环引用的内存泄露风险；例如<code>$(&#39;#head&#39;).data(name:&#39;hello&#39;)</code>是在id为head的这个元素上绑定了一个数据，其名为name，值为’hello’，下次这样引用<code>$(&#39;#head&#39;).data(name)</code>。</li>
</ul>
<h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="写出以下功能对应的-Jq-方法："><a href="#写出以下功能对应的-Jq-方法：" class="headerlink" title="写出以下功能对应的 Jq 方法："></a>写出以下功能对应的 Jq 方法：</h4><p>1.给元素 $node 添加 class active，给元素 $noed 删除 class active</p>
<pre><code>$node.addClass(&apos;active&apos;);
$noed.removeClass(&apos;active&apos;);
</code></pre><p>2.展示元素$node, 隐藏元素$node</p>
<pre><code>$node.show(); //展示         
$node.hide()；//隐藏  
</code></pre><p>3.获取元素$node 的 属性: id、src、title， 修改以上属性</p>
<pre><code>$node.attr(&apos;id&apos;);
$node.attr(&apos;src&apos;);
$node.attr(&apos;title&apos;);
$node.attr({
  id:&apos; &apos;，
  src:&apos; &apos;，
  title:&apos; &apos;，
});
</code></pre><p>4.给$node 添加自定义属性data-src</p>
<pre><code>$node.attr(&apos;data-src&apos;:&apos; &apos;);
</code></pre><p>5.在$ct 内部最开头添加元素$node</p>
<pre><code>$ct.prepend($node);
</code></pre><p>6.在$ct 内部最末尾添加元素$node</p>
<pre><code>$ct.append($node);
</code></pre><p>7.删除$node</p>
<pre><code>$node.remove();
</code></pre><p>8.把$ct里内容清空</p>
<pre><code>$ct.text(&apos;&apos;);
$ct.empty();
</code></pre><p>9.在$ct 里设置 html <div class="btn"></div></p>
<pre><code>$ct.html(&apos;&lt;div class=&quot;btn&quot;&gt;&lt;/div&gt;&apos;);
</code></pre><p>10.获取、设置$node 的宽度、高度(分别不包括内边距、包括内边距、包括边框、包括外边距)</p>
<pre><code>$node.width();    //获得宽度 不包括内边距 仅内容大小
$node.width(30);    //设置宽度 
$node.height();     //获得高度   
$node.height(30);    //设置高度  
$node.innerWidth();    //包含内边距用inner
$node.outerWidth();   //包含边框用outer
$node.outerWidth(true);  //包含外边距用outer+true
</code></pre><p>11.获取窗口滚动条垂直滚动距离</p>
<pre><code>$(document).scrollTop();
</code></pre><p>12.获取$node 到根节点水平、垂直偏移距离</p>
<pre><code>$node.offset();
</code></pre><p>13.修改$node 的样式，字体颜色设置红色，字体大小设置14px</p>
<pre><code>$node.css({
  &apos;color&apos;: &apos;red&apos;,
  &apos;font-size&apos;: &apos;14px&apos;
});
</code></pre><p>14.遍历节点，把每个节点里面的文本内容重复一遍</p>
<pre><code>.each(function(index,element){
  $(this).text($(this).text()+$(this).text());
});
</code></pre><p>15.从$ct 里查找 class 为 .item的子元素</p>
<pre><code>$ct.find(&apos;.item&apos;);
</code></pre><p>16.获取$ct 里面的所有孩子</p>
<pre><code>$ct.children();
</code></pre><p>17.对于$node，向上找到 class 为’.ct’的父亲，在从该父亲找到’.panel’的孩子</p>
<pre><code>$node.parents(&apos;.ct&apos;).find(&apos;.panel&apos;)
</code></pre><p>18.获取选择元素的数量</p>
<pre><code>.length;
</code></pre><p>19.获取当前元素在兄弟中的排行</p>
<pre><code>.index()；
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/10/Jquery常用方法/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Jquery-DOM&amp;事件" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/09/Jquery-DOM&事件/">Jquery Dom、事件</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jquery/">Jquery</a></li></ul>
</div>
        <time datetime="2016-05-09T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-09
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="库和框架的区别"><a href="#库和框架的区别" class="headerlink" title="库和框架的区别"></a>库和框架的区别</h4><ul>
<li>看到的经典回答：<ul>
<li>框架帮你挖好坑，你来填！库是给你一把铲子你自己挖！</li>
<li>You call library ,Framework calls you.<ul>
<li><strong>库是一些方法的集合</strong>；例如你想修改DOM元素时需要选中、修改、放回去步骤繁琐，这时我们可以自己写个函数来专门实现这种功能，你只需要放参数进来它就返回结果给你，不用重复写；这个函数就是库里面的方法，库里面放了很多方法。</li>
<li><strong>框架是设计好的结构，是个可拓展的半成品</strong>；例如有一群人都想建房子，那么框架会帮你打好地基、搭好承重梁，等于这个房子的主体搞定了，然后不同人按自己的需要去添砖加瓦去构建自己想要的房子；</li>
</ul>
</li>
</ul>
</li>
<li>从本质上来看，库和框架都是为了减少我们的工作量而服务的。库是着眼于小方面帮你做好工具让你不用每次干活都先造工具，但你去干什么活它不管；而框架呢是着眼于大方面，把一些通用的、基础的（比如不管是谁每次建房子前都要先打地基）给打包在一起，要建房就把那一堆放上去，然后在此基础上再自己去做，但你要用对，建房地基包不能拿去做桥梁的！</li>
</ul>
<h4 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h4><ul>
<li>jquery是一个又小又快功能丰富的javascript库，它可以让你对DOM元素的遍历和操作、事件、ajax和动画等变得更简单，不需要像原生js那么繁琐，它帮你封装好了，提供了很多API你只要去调用它就能返回结果给你，而且它的方法还兼容各个版本的浏览器。</li>
</ul>
<h4 id="jquery-对象和-DOM-原生对象的区别及互相转化"><a href="#jquery-对象和-DOM-原生对象的区别及互相转化" class="headerlink" title="jquery 对象和 DOM 原生对象的区别及互相转化"></a>jquery 对象和 DOM 原生对象的区别及互相转化</h4><ul>
<li>jauery对象的外层都是一个中括号包裹的，通过使用<code>$( )</code>得到的，类似<code>[&lt;p&gt;我是段落&lt;/p&gt;]</code>，只有jauery对象才能使用jquery的方法。因为是类数组对象，所以我们可以加个中括号包裹的数字即可得到原生DOM对象，<code>[&lt;p&gt;我是段落&lt;/p&gt;][0]</code>；另外jquery还提供了一个get方法来实现，如<code>[&lt;p&gt;我是段落&lt;/p&gt;].get(0)</code>。</li>
<li>DOM原生对象就是我们通过<code>geElementBy xx</code>得到的节点，例如<code>&lt;p&gt;我是段落&lt;/p&gt;</code>；可以使用<code>$( )</code>来包裹DOM原生对象从而得到jquery对象，<code>$(DOM原生对象)</code>。</li>
</ul>
<h4 id="jquery中事件绑定"><a href="#jquery中事件绑定" class="headerlink" title="jquery中事件绑定"></a>jquery中事件绑定</h4><ul>
<li>jquery中使用on来绑定事件，<code>对象.on(&#39;事件名称&#39;，&#39;处理函数&#39;)</code>。</li>
</ul>
<h4 id="bind、unbind、delegate、live、on、off的作用；"><a href="#bind、unbind、delegate、live、on、off的作用；" class="headerlink" title="bind、unbind、delegate、live、on、off的作用；"></a>bind、unbind、delegate、live、on、off的作用；</h4><ul>
<li><code>bind</code>在jquery1.7之前的版本中用于直接给一个元素绑定事件，所以在绑定前元素必须是已存在的。</li>
<li><code>unbind</code>可以移除元素上用bind绑定的事件，如果没有参数就移除元素上的所有事件。</li>
<li><code>delegate</code>在jquery1.7之前的版本中使用，一般用于给父元素绑定一个或多个事件，只要匹配的子元素发生事件就会触发。</li>
<li><code>live</code>在jquery1.7版本被废弃了，给匹配的所有元素绑定一个事件。</li>
<li><code>on</code>给匹配的元素绑定事件处理函数，可以有多个事件。</li>
<li><code>off</code>移除用on绑定的事件，如果没有参数则移除所有事件。</li>
</ul>
<p>推荐使用on来绑定事件，因为它更灵活，而且旧版本中其他绑定方法它都能实现达成了统一。</p>
<h4 id="使用on绑定事件使用事件代理的写法"><a href="#使用on绑定事件使用事件代理的写法" class="headerlink" title="使用on绑定事件使用事件代理的写法"></a>使用on绑定事件使用事件代理的写法</h4><ul>
<li><p>使用on绑定事件代理写法如下：为ul绑定事件，当li元素发生事件时，触发处理函数。</p>
<pre><code>$(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos;, function(){ });
</code></pre></li>
</ul>
<h4 id="jquery-中如何展示-隐藏元素？"><a href="#jquery-中如何展示-隐藏元素？" class="headerlink" title="jquery 中如何展示/隐藏元素？"></a>jquery 中如何展示/隐藏元素？</h4><ul>
<li><code>$().hide()</code>来隐藏元素，可以设置参数来控制执行的时间、方式、回调参数等。</li>
<li><code>$().show()</code>来隐藏元素，可以设置参数来控制执行的时间、方式、回调参数等。</li>
</ul>
<h4 id="jquery-动画的使用"><a href="#jquery-动画的使用" class="headerlink" title="jquery 动画的使用"></a>jquery 动画的使用</h4><ul>
<li>使用<code>.animate( )</code>来使用动画，<code>元素.annimate（css属性：值，opts）</code>，opt里可以设置较多东西，时间、方式、速度、回调函数等，可以按需要去jquery官网查阅，对于css属性部分要注意必须是值可数字化的css属性，例如宽高可以而背景色就不行。</li>
</ul>
<h4 id="元素内部-HTML-内容设置和获取、元素内部文本的设置和获取？"><a href="#元素内部-HTML-内容设置和获取、元素内部文本的设置和获取？" class="headerlink" title="元素内部 HTML 内容设置和获取、元素内部文本的设置和获取？**"></a>元素内部 HTML 内容设置和获取、元素内部文本的设置和获取？**</h4><ul>
<li>HTML内容使用jquery的<code>.html( )</code>，括号内不带内容表示获取所选对象的html内容，带内容的话则将用括号内的内容覆盖其内部html内容。原生js中用<code>.innerHTML</code>获取，用赋值来设置内容。</li>
<li>文本内容使用jquery的<code>.text( )</code>，括号中不带内容表示获取所选对象的文本内容(注意同样是忽略html标签进行文本拼接)，带内容的话则将用括号内的内容覆盖其内部html内容。原生js中用<code>.innerText</code>获取，用赋值来设置内容。</li>
</ul>
<h4 id="表单用户输入或者选择的内容设置和获取、元素属性的设置和获取"><a href="#表单用户输入或者选择的内容设置和获取、元素属性的设置和获取" class="headerlink" title="表单用户输入或者选择的内容设置和获取、元素属性的设置和获取"></a>表单用户输入或者选择的内容设置和获取、元素属性的设置和获取</h4><ul>
<li>和原生JS中<code>input对象.value</code>类似，jquery中可以使用<code>$( ).val( )</code>来获取表单输入的内容。</li>
<li>元素属性的获取在原生JS中是使用<code>元素.getAttribute</code>，使用<code>元素.settAttribute</code>来设置；而在jquery中获取和设置两种操作是同一个方法，<code>$( ).attr(&#39;属性名&#39;)</code>来获取属性值，<code>$( ).attr(&#39;属性名&#39;，&#39;值&#39;)</code>来对属性值进行设置。</li>
</ul>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/09/Jquery-DOM&事件/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Ajax基础" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/05/06/Ajax基础/">Ajax基础</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
</div>
        <time datetime="2016-05-06T06:43:41.000Z" itemprop="datePublished" class="post-tiem">
  2016-05-06
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><ul>
<li><code>Ajax</code>全称是<code>Asynchronous JavaScript and XML</code>，指的是通过Javascript脚本发起HTTP通信；</li>
<li>它可以使用原生的<code>XMLHttpRequest对象</code>向服务器发出HTTP请求，这个请求可以是同步或异步的（一般是异步），建立连接后可以得到服务器的数据，我们就可以利用得到的数据通过JS来更新部分页面而无需对整个页面进行刷新。</li>
</ul>
<h4 id="前后端开发联调需要注意哪些事情？后端接口完成前如何-mock-数据？"><a href="#前后端开发联调需要注意哪些事情？后端接口完成前如何-mock-数据？" class="headerlink" title="前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？"></a>前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？</h4><ul>
<li>前后端联调需要注意：①确定接口信息；有哪些接口，哪些参数，以什么样的请求等，一般要确定详细的接口文档。②确定要填充的数据，哪里填充图片，哪里填充文本信息等。</li>
<li>在后端接口完成前，我们可以根据接口文档，使用假数据来验证我们制作的页面响应和接口是否正常，可以使用<a href="http://mockjs.com/" target="_blank" rel="external">Mock.js</a>，它能拦截ajax请求并根据请求中的内容来随机生成符合你要求的假数据，模拟后端环境让你完成对页面和接口的测试。</li>
</ul>
<h4 id="点击按钮，使用-ajax-获取数据，如何在数据到来之前防止重复点击"><a href="#点击按钮，使用-ajax-获取数据，如何在数据到来之前防止重复点击" class="headerlink" title="点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击?"></a>点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击?</h4><ul>
<li>自己的想法：依目前所学，只有js能实现；第一反应是点击后我把事件移除，你随便点，等加载完成后我在处理函数中再给它绑事件；或者我再给按钮绑个事件，点击后把自己的class给改掉让ajax不能正常触发，不过改class可能会有改变样式的风险，写样式时可以预先加个比如interrupt的类。</li>
<li>网上搜索了一下：自己封装加个比对-如果ajax请求一致的话就不进行提交、提交后把<code>button disable</code>掉、如果点完一个又去点了另外一个的话就<code>abort</code>之前的请求、加个<code>setTimeout+clearTimeOut</code>避免恶意快速点击等。</li>
</ul>
<h4 id="用js封装了一个-ajax-函数"><a href="#用js封装了一个-ajax-函数" class="headerlink" title="用js封装了一个 ajax 函数"></a>用js封装了一个 ajax 函数</h4><pre><code>function ajax(opts){
  var request = new  XMLHttpRequest();
  var str = &apos;&apos;;
  for(i in opts.data){
    str += i+&apos;=&apos;+opts.data[i]+&apos;&amp;&apos;;
  }
  str = str.substr(0, str.length-1); 
  if(opts.type.toLowerCase() === &apos;get&apos;){
    request.open(&apos;GET&apos;, opts.url+&apos;?&apos;+str, true);
    request.send();
  }
  if(opt.type.toLowerCase() === &apos;post&apos;){
    resuest.open(&apos;POST&apos;, opt.url, true);
    ajax.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
    request.send(str);
  }
  request.onreadystatechange=function(){
    if(request.readyState==4 &amp;&amp; request.status==200){
      var responsetext=JSON.parse(request.responseText);
      opts.success(responsetext);
    }
    if(request.status!==200){
      opts.error();
    }
  }
}
document.querySelector(&apos;#btn&apos;).addEventListener(&apos;click&apos;, function(){
  ajax({
    url: &apos;getData.php&apos;,   //接口地址
    type: &apos;get&apos;,               // 类型， post 或者 get,
    data: {
      username: &apos;xiaoming&apos;,
      password: &apos;abcd1234&apos;
    },
    success: function(ret){
        console.log(ret);       // {status: 0}
      },
      error: function(){
       console.log(&apos;出错了&apos;)
     }
   })
});
</code></pre>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/05/06/Ajax基础/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
  </ul>
  
    <nav id="page-nav">
      <div class="inner">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
      </div>
    </nav>
  


    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
